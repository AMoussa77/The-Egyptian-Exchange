<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Egyptian Exchange Stocks</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            color: #e0e0e0;
            overflow-x: hidden; /* Prevent horizontal scroll */
        }

        .header {
            background: rgba(20, 20, 40, 0.95);
            backdrop-filter: blur(10px);
            padding: 8px 20px;
            box-shadow: 0 2px 20px rgba(0, 0, 0, 0.3);
            position: sticky;
            top: 0;
            z-index: 100;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header-left {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        .header-right {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }

        .record-counter {
            margin: 5px 0;
            font-size: 0.9em;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .market-status {
            margin: 5px 0;
            font-size: 0.9em;
        }

        .market-status-indicator {
            padding: 4px 8px;
            border-radius: 12px;
            font-weight: 600;
            font-size: 0.85em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .market-status-indicator.open {
            background: rgba(46, 204, 113, 0.2);
            border: 1px solid rgba(46, 204, 113, 0.4);
            color: #2ecc71;
        }

        .market-status-indicator.closed {
            background: rgba(231, 76, 60, 0.2);
            border: 1px solid rgba(231, 76, 60, 0.4);
            color: #e74c3c;
        }

        .market-status-indicator.loading {
            background: rgba(255, 193, 7, 0.2);
            border: 1px solid rgba(255, 193, 7, 0.4);
            color: #ffc107;
        }

        .market-countdown {
            display: inline-block;
            margin-left: 10px;
            padding: 4px 8px;
            background: linear-gradient(135deg, #f59e0b, #d97706);
            color: #ffffff;
            border-radius: 6px;
            font-size: 0.75em;
            font-weight: 600;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
            box-shadow: 0 2px 4px rgba(245, 158, 11, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            animation: countdown-pulse 1.5s ease-in-out infinite alternate;
        }

        @keyframes countdown-pulse {
            0% {
                box-shadow: 0 2px 4px rgba(245, 158, 11, 0.3);
                transform: scale(1);
            }
            100% {
                box-shadow: 0 4px 8px rgba(245, 158, 11, 0.5);
                transform: scale(1.02);
            }
        }

        /* News Styles */
        .news-container {
            max-width: 100%;
        }

        .news-list {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .news-item {
            background: rgba(40, 40, 60, 0.6);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .news-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(74, 144, 226, 0.2);
            border-color: rgba(74, 144, 226, 0.3);
        }

        .news-item.breaking {
            border-left: 4px solid #e74c3c;
            background: rgba(231, 76, 60, 0.1);
        }

        .news-item.important {
            border-left: 4px solid #f39c12;
            background: rgba(243, 156, 18, 0.1);
        }

        .news-item.update {
            border-left: 4px solid #3498db;
            background: rgba(52, 152, 219, 0.1);
        }

        .news-header-info {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 12px;
        }

        .news-title {
            color: #ffffff;
            font-size: 1.2em;
            font-weight: 600;
            margin: 0 0 8px 0;
            line-height: 1.4;
        }

        .news-category {
            background: rgba(74, 144, 226, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.75em;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .news-category.breaking {
            background: rgba(231, 76, 60, 0.8);
        }

        .news-category.important {
            background: rgba(243, 156, 18, 0.8);
        }

        .news-category.update {
            background: rgba(52, 152, 219, 0.8);
        }

        .news-content {
            color: #e0e0e0;
            line-height: 1.6;
            margin-bottom: 15px;
        }

        .news-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.85em;
            color: #b0b0b0;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding-top: 12px;
        }

        .news-date {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .news-source {
            display: flex;
            align-items: center;
            gap: 5px;
            font-weight: 500;
        }

        .news-badge {
            display: inline-block;
            background: rgba(46, 204, 113, 0.2);
            color: #2ecc71;
            padding: 2px 6px;
            border-radius: 8px;
            font-size: 0.7em;
            font-weight: 600;
            text-transform: uppercase;
            margin-left: 8px;
        }

        .news-badge.new {
            background: rgba(231, 76, 60, 0.2);
            color: #e74c3c;
            animation: pulse 2s infinite;
        }

        .news-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .news-btn {
            background: rgba(74, 144, 226, 0.2);
            color: #4a90e2;
            border: 1px solid rgba(74, 144, 226, 0.3);
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.8em;
            cursor: pointer;
            transition: all 0.2s ease;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }

        .news-btn:hover {
            background: rgba(74, 144, 226, 0.3);
            transform: translateY(-1px);
        }

        /* News Icon in Header */
        .news-icon-btn {
            position: relative;
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }

        .news-notification-dot {
            position: absolute;
            top: -2px;
            right: -2px;
            width: 8px;
            height: 8px;
            background: #e74c3c;
            border-radius: 50%;
            animation: pulse 2s infinite;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        /* News Modal Specific Styles */
        .news-modal-content {
            max-width: 800px;
            width: 90%;
            max-height: 80vh;
        }

        .news-modal-body {
            max-height: 60vh;
            overflow-y: auto;
            padding: 0;
        }

        .news-modal-body .news-container {
            padding: 20px;
        }

        .news-modal-body .news-list {
            gap: 15px;
        }

        .news-modal-body .news-item {
            padding: 15px;
        }

        /* Compact news items in modal */
        .news-modal-body .news-title {
            font-size: 1.1em;
            margin-bottom: 6px;
        }

        .news-modal-body .news-content {
            margin-bottom: 10px;
            font-size: 0.9em;
        }

        .news-modal-body .news-meta {
            padding-top: 8px;
            font-size: 0.8em;
        }

        /* Exchange News Styles */
        .exchange-news-container {
            max-width: 100%;
            padding: 0;
            margin: 0;
            height: 100%;
            box-sizing: border-box;
        }

        .exchange-news-header {
            padding: 10px 20px 10px 20px;
            margin: 0;
            background: transparent;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .exchange-news-list {
            display: flex;
            flex-direction: column;
            gap: 15px;
            padding: 10px 20px 0 20px;
            margin: 0;
        }

        .exchange-news-item {
            background: rgba(40, 40, 60, 0.6);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            direction: rtl; /* Arabic text direction */
        }

        .exchange-news-item {
            cursor: pointer;
        }

        .exchange-news-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(74, 144, 226, 0.2);
            border-color: rgba(74, 144, 226, 0.3);
        }

        .exchange-news-item:active {
            transform: translateY(0);
            box-shadow: 0 4px 15px rgba(74, 144, 226, 0.15);
        }

        .exchange-news-item.official {
            border-left: 4px solid #2ecc71;
            background: rgba(46, 204, 113, 0.1);
        }

        .exchange-news-item.announcement {
            border-left: 4px solid #3498db;
            background: rgba(52, 152, 219, 0.1);
        }

        .exchange-news-header-info {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 12px;
            direction: rtl;
        }

        .exchange-news-title {
            color: #ffffff;
            font-size: 1.1em;
            font-weight: 600;
            margin: 0 0 8px 0;
            line-height: 1.4;
            direction: rtl;
            text-align: right;
        }

        .exchange-news-company {
            background: rgba(74, 144, 226, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.75em;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            direction: ltr;
        }

        .exchange-news-content {
            color: #e0e0e0;
            line-height: 1.6;
            margin-bottom: 15px;
            direction: rtl;
            text-align: right;
            font-size: 0.95em;
        }

        .exchange-news-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.85em;
            color: #b0b0b0;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding-top: 12px;
            direction: rtl;
        }

        .exchange-news-date {
            display: flex;
            align-items: center;
            gap: 5px;
            direction: ltr;
        }

        .exchange-news-source {
            display: flex;
            align-items: center;
            gap: 5px;
            font-weight: 500;
            direction: ltr;
        }

        .exchange-news-link {
            color: rgba(74, 144, 226, 0.9);
            font-size: 0.85em;
            display: flex;
            align-items: center;
            gap: 5px;
            font-weight: 500;
            direction: ltr;
        }

        .exchange-news-item:hover .exchange-news-link {
            color: rgba(74, 144, 226, 1);
        }

        .exchange-news-badge {
            display: inline-block;
            background: rgba(46, 204, 113, 0.2);
            color: #2ecc71;
            padding: 2px 6px;
            border-radius: 8px;
            font-size: 0.7em;
            font-weight: 600;
            text-transform: uppercase;
            margin-right: 8px;
        }

        .exchange-news-badge.new {
            background: rgba(231, 76, 60, 0.2);
            color: #e74c3c;
            animation: pulse 2s infinite;
        }

        .exchange-news-info {
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(52, 152, 219, 0.1);
            border-radius: 8px;
            border: 1px solid rgba(52, 152, 219, 0.2);
        }

        .record-counter span {
            background: rgba(0, 150, 255, 0.2);
            padding: 4px 8px;
            border-radius: 12px;
            border: 1px solid rgba(0, 150, 255, 0.3);
            color: #00bfff;
            font-weight: 500;
        }

        .loading-spinner {
            width: 16px;
            height: 16px;
            border: 2px solid rgba(0, 150, 255, 0.3);
            border-top: 2px solid #00bfff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .header h1 {
            color: #ffffff;
            font-size: 1.2em;
            margin: 0 0 3px 0;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }

        .header p {
            color: #b0b0b0;
            font-size: 0.8em;
            margin: 0 0 8px 0;
        }

        .controls {
            display: flex;
            gap: 8px;
            margin-top: 3px;
        }


        .btn {
            background: linear-gradient(45deg, #4a90e2, #357abd);
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 3px 10px rgba(74, 144, 226, 0.3);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(74, 144, 226, 0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-small {
            padding: 4px 8px;
            font-size: 10px;
            border-radius: 15px;
        }

        .btn-watchlist {
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
        }

        .btn-watchlist:hover {
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.4);
        }

        .btn-wallet {
            background: linear-gradient(45deg, #2ecc71, #27ae60);
        }

        .btn-wallet:hover {
            box-shadow: 0 6px 20px rgba(46, 204, 113, 0.4);
        }

        .btn-remove {
            background: linear-gradient(45deg, #95a5a6, #7f8c8d);
        }

        .btn-remove:hover {
            box-shadow: 0 6px 20px rgba(149, 165, 166, 0.4);
        }

        /* Wallet Styles */
        .wallet-header {
            margin-bottom: 20px;
        }

        .portfolio-summary {
            flex: 1;
        }

        .summary-card {
            background: linear-gradient(135deg, rgba(46, 204, 113, 0.1), rgba(39, 174, 96, 0.1));
            border: 1px solid rgba(46, 204, 113, 0.3);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }

        .summary-card h3 {
            margin: 0 0 15px 0;
            color: #2ecc71;
            font-size: 1.2em;
        }

        .summary-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .stat {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .stat-label {
            font-size: 0.9em;
            color: #b0b0b0;
            font-weight: 500;
        }

        .stat-value {
            font-size: 1.1em;
            font-weight: 600;
            color: #ffffff;
        }

        .stat-value.positive {
            color: #2ecc71;
        }

        .stat-value.negative {
            color: #e74c3c;
        }

        .add-stock-section {
            display: flex;
            align-items: center;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            color: #ffffff;
            font-weight: 500;
        }

        .form-input {
            width: 100%;
            padding: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            font-size: 14px;
        }

        .form-input:focus {
            outline: none;
            border-color: #4a90e2;
            box-shadow: 0 0 0 2px rgba(74, 144, 226, 0.2);
        }

        .form-input::placeholder {
            color: #b0b0b0;
        }

        .stock-info {
            background: rgba(74, 144, 226, 0.1);
            border: 1px solid rgba(74, 144, 226, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
        }

        .stock-info h4 {
            margin: 0 0 10px 0;
            color: #4a90e2;
            font-size: 1em;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .info-label {
            color: #b0b0b0;
            font-weight: 500;
        }

        .info-value {
            color: #ffffff;
            font-weight: 600;
        }

        .info-value.positive {
            color: #2ecc71;
        }

        .info-value.negative {
            color: #e74c3c;
        }

        .tabs {
            display: flex;
            justify-content: center;
            margin: 15px 0;
            background: rgba(40, 40, 60, 0.3);
            border-radius: 25px;
            padding: 5px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .tab {
            background: transparent;
            color: #e0e0e0;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            margin: 0 5px;
        }

        .tab.active {
            background: rgba(74, 144, 226, 0.8);
            color: white;
            box-shadow: 0 4px 15px rgba(74, 144, 226, 0.3);
        }

        .tab:hover:not(.active) {
            background: rgba(255, 255, 255, 0.1);
        }

        .tab-content {
            display: none;
            padding: 20px;
            margin: 0;
            min-height: calc(100vh - 120px);
            box-sizing: border-box;
        }

        .tab-content.active {
            display: block;
        }

        /* Ensure exchange news tab has seamless integration */
        #exchange-news {
            padding: 0 !important;
            margin: 0;
            background: transparent;
            height: 100%;
        }

        /* Override tab-content padding specifically for exchange news */
        #exchange-news.tab-content {
            padding: 0 !important;
        }

        /* Override container padding when exchange news is active */
        .container.exchange-news-active {
            padding-top: 0 !important;
        }

        .main-content.exchange-news-active {
            padding-top: 0 !important;
        }

        /* Remove any additional spacing for exchange news */
        .exchange-news-active .tab-content {
            margin-top: 0;
            padding-top: 0;
        }

        /* Smooth scrolling for exchange news */
        #exchange-news::-webkit-scrollbar {
            width: 8px;
        }

        #exchange-news::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }

        #exchange-news::-webkit-scrollbar-thumb {
            background: rgba(74, 144, 226, 0.5);
            border-radius: 4px;
        }

        #exchange-news::-webkit-scrollbar-thumb:hover {
            background: rgba(74, 144, 226, 0.7);
        }

        /* Loading states for exchange news */
        .exchange-news-container .loading {
            padding: 20px;
            margin: 0;
            background: transparent;
            text-align: center;
        }

        .exchange-news-container .error {
            padding: 10px 20px;
            margin: 0;
            background: transparent;
            text-align: center;
        }

        /* Responsive design for exchange news */
        @media (max-width: 768px) {
            .exchange-news-header {
                padding: 15px 15px 10px 15px;
            }
            
            .exchange-news-list {
                gap: 12px;
                padding: 8px 15px 0 15px;
            }
            
            .exchange-news-container .loading,
            .exchange-news-container .error {
                padding: 10px 15px;
            }
            
            .exchange-news-item {
                padding: 16px;
            }
            
            .exchange-news-header-info {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }
            
            .exchange-news-meta {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }
        }

        @media (max-width: 480px) {
            .exchange-news-header {
                padding: 12px 12px 8px 12px;
            }
            
            .exchange-news-list {
                padding: 8px 12px 0 12px;
            }
            
            .exchange-news-container .loading,
            .exchange-news-container .error {
                padding: 10px 12px;
            }
            
            .exchange-news-item {
                padding: 14px;
            }
            
            .exchange-news-title {
                font-size: 0.95em;
                line-height: 1.4;
            }
        }

        .status {
            text-align: center;
            margin: 10px 0;
            padding: 10px;
            border-radius: 10px;
            font-weight: 600;
        }

        .status.success {
            background: rgba(46, 204, 113, 0.2);
            color: #2ecc71;
            border: 1px solid rgba(46, 204, 113, 0.4);
        }

        .status.error {
            background: rgba(231, 76, 60, 0.2);
            color: #ff6b6b;
            border: 1px solid rgba(231, 76, 60, 0.4);
        }

        .status.info {
            background: rgba(74, 144, 226, 0.2);
            color: #4a90e2;
            border: 1px solid rgba(74, 144, 226, 0.4);
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            padding-bottom: 100px; /* Increased bottom padding to prevent footer overlap */
            min-height: calc(100vh - 200px); /* Ensure minimum height */
            overflow-y: auto; /* Single scroll area for the entire container */
        }

        /* Ensure main content has proper spacing */
        .main-content {
            padding-bottom: 60px; /* Additional padding for main content */
        }

        .search-container {
            margin-bottom: 20px;
            display: flex;
            justify-content: center;
        }

        .search-input {
            width: 300px;
            padding: 12px 20px;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            background: rgba(40, 40, 60, 0.8);
            color: #e0e0e0;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            outline: none;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .search-input:focus {
            box-shadow: 0 6px 20px rgba(74, 144, 226, 0.3);
            transform: translateY(-1px);
            border-color: rgba(74, 144, 226, 0.5);
        }

        .search-input::placeholder {
            color: #888;
        }

        .stocks-table {
            background: rgba(30, 30, 50, 0.95);
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .table-header {
            background: linear-gradient(45deg, #1a1a2e, #16213e);
            color: white;
            padding: 20px;
            text-align: center;
            font-size: 1.2em;
            font-weight: 600;
        }

        .table-container {
            margin-bottom: 20px; /* Add margin to ensure space above footer */
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }

        th {
            background: linear-gradient(45deg, #2c3e50, #34495e);
            color: white;
            padding: 15px 10px;
            text-align: center;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
            cursor: pointer;
            user-select: none;
            transition: background-color 0.3s ease;
            position: relative;
        }

        th:hover {
            background: linear-gradient(45deg, #34495e, #2c3e50);
        }

        th.sortable {
            padding-right: 25px;
        }

        th.sortable::after {
            content: '‚Üï';
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 12px;
            opacity: 0.7;
        }

        th.sort-asc::after {
            content: '‚Üë';
            opacity: 1;
        }

        th.sort-desc::after {
            content: '‚Üì';
            opacity: 1;
        }

        td {
            padding: 12px 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            transition: background-color 0.2s ease;
            text-align: center;
            color: #e0e0e0;
        }

        tr:hover {
            background: rgba(74, 144, 226, 0.1);
        }

        tr:nth-child(even) {
            background: rgba(255, 255, 255, 0.02);
        }

        .price-positive {
            color: #2ecc71;
            font-weight: 600;
        }

        .price-negative {
            color: #ff6b6b;
            font-weight: 600;
        }

        .price-neutral {
            color: #b0b0b0;
            font-weight: 600;
        }

        .loading {
            text-align: center;
            padding: 40px;
            font-size: 1.2em;
            color: #b0b0b0;
        }

        .spinner {
            border: 4px solid rgba(74, 144, 226, 0.3);
            border-top: 4px solid #4a90e2;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .last-updated {
            position: fixed;
            top: 15px;
            right: 15px;
            color: #b0b0b0;
            font-size: 0.75em;
            background: rgba(30, 30, 50, 0.9);
            padding: 6px 12px;
            border-radius: 12px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            font-weight: 500;
        }

        .last-updated.updating {
            color: white;
            background: rgba(74, 144, 226, 0.9);
            border-color: rgba(74, 144, 226, 0.5);
        }

        .column-toggle {
            position: fixed;
            top: 100px;
            right: 15px;
            background: rgba(30, 30, 50, 0.95);
            border-radius: 12px;
            padding: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 999;
            max-width: 250px;
            font-size: 0.85em;
        }

        .column-toggle h3 {
            margin: 0 0 10px 0;
            color: #ffffff;
            font-size: 0.9em;
            font-weight: 600;
        }

        .column-toggle-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
            cursor: pointer;
            padding: 3px 0;
            border-radius: 5px;
            transition: background-color 0.2s ease;
        }

        .column-toggle-item:hover {
            background: rgba(74, 144, 226, 0.1);
        }

        .column-toggle-item input[type="checkbox"] {
            margin-right: 8px;
            cursor: pointer;
        }

        .column-toggle-item label {
            cursor: pointer;
            flex: 1;
            color: #e0e0e0;
            font-size: 0.8em;
        }

        .column-toggle-toggle {
            position: fixed;
            top: 50px;
            right: 15px;
            background: rgba(30, 30, 50, 0.95);
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1001;
            font-size: 16px;
            color: #e0e0e0;
            transition: all 0.3s ease;
        }

        .column-toggle-toggle:hover {
            background: rgba(74, 144, 226, 0.2);
            transform: scale(1.05);
        }

        .column-toggle.hidden {
            display: none;
        }

        /* Custom Scrollbar Styles */
        ::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(40, 40, 60, 0.3);
            border-radius: 6px;
        }

        ::-webkit-scrollbar-thumb {
            background: linear-gradient(45deg, #4a90e2, #357abd);
            border-radius: 6px;
            border: 2px solid rgba(40, 40, 60, 0.3);
            transition: all 0.3s ease;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(45deg, #5ba0f2, #4a8acd);
            box-shadow: 0 2px 8px rgba(74, 144, 226, 0.3);
        }

        ::-webkit-scrollbar-thumb:active {
            background: linear-gradient(45deg, #3a80d2, #2a6a9d);
        }

        ::-webkit-scrollbar-corner {
            background: rgba(40, 40, 60, 0.3);
        }

        /* Firefox scrollbar styles */
        * {
            scrollbar-width: thin;
            scrollbar-color: #4a90e2 rgba(40, 40, 60, 0.3);
        }

        /* Modal scrollbar styles */
        .modal-content::-webkit-scrollbar {
            width: 8px;
        }

        .modal-content::-webkit-scrollbar-track {
            background: rgba(20, 20, 40, 0.5);
            border-radius: 4px;
        }

        .modal-content::-webkit-scrollbar-thumb {
            background: linear-gradient(45deg, #4a90e2, #357abd);
            border-radius: 4px;
            border: 1px solid rgba(20, 20, 40, 0.5);
        }

        .modal-content::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(45deg, #5ba0f2, #4a8acd);
        }

        /* Settings modal specific scrollbar */
        .modal-body::-webkit-scrollbar {
            width: 8px;
        }

        .modal-body::-webkit-scrollbar-track {
            background: rgba(30, 30, 50, 0.3);
            border-radius: 4px;
        }

        .modal-body::-webkit-scrollbar-thumb {
            background: linear-gradient(45deg, #4a90e2, #357abd);
            border-radius: 4px;
            border: 1px solid rgba(30, 30, 50, 0.3);
        }

        .modal-body::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(45deg, #5ba0f2, #4a8acd);
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }
            
            .header-left, .header-right {
                align-items: flex-start;
            }
            
            .header h1 {
                font-size: 1.1em;
            }
            
            .header p {
                font-size: 0.75em;
            }
            
            .btn {
                padding: 5px 10px;
                font-size: 10px;
            }
            
            .container {
                padding: 10px;
            }
            
            .search-input {
                width: 100%;
                max-width: 300px;
            }
            
            table {
                font-size: 12px;
            }
            
            th, td {
                padding: 8px 5px;
            }
            
            .last-updated {
                top: 10px;
                right: 10px;
                font-size: 0.7em;
                padding: 4px 8px;
            }
            
            .column-toggle {
                top: 90px;
                right: 10px;
                max-width: 200px;
                font-size: 0.8em;
            }
            
            .column-toggle-toggle {
                top: 45px;
                right: 10px;
                width: 35px;
                height: 35px;
                font-size: 14px;
            }
            
            .container {
                padding-bottom: 120px; /* Extra padding on mobile */
            }
            
            .main-content {
                padding-bottom: 80px; /* Extra padding on mobile */
            }
            
            .modal-content {
                max-height: 90vh; /* More height on mobile */
                width: 95%;
            }
            
            .modal-body {
                max-height: calc(90vh - 120px); /* Adjust for mobile */
            }
        }

        /* Modal Styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            z-index: 10000;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            border-radius: 15px;
            padding: 0;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow: hidden;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            background: linear-gradient(45deg, #2c3e50, #34495e);
            padding: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0; /* Prevent header from shrinking */
        }

        .modal-header h2 {
            color: white;
            margin: 0;
            font-size: 1.3em;
        }

        .close-btn {
            background: none;
            border: none;
            color: #e0e0e0;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .close-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        .modal-body {
            padding: 20px;
            color: #e0e0e0;
            overflow-y: auto;
            flex: 1;
            max-height: calc(80vh - 140px); /* Account for header and footer */
        }

        .modal-footer {
            padding: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            flex-shrink: 0; /* Prevent footer from shrinking */
        }

        .btn-secondary {
            background: linear-gradient(45deg, #95a5a6, #7f8c8d);
        }

        .btn-secondary:hover {
            box-shadow: 0 6px 20px rgba(149, 165, 166, 0.4);
        }

        .setting-item {
            margin: 15px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .setting-item label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            color: #e0e0e0;
        }

        .setting-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .setting-item input[type="time"] {
            background: rgba(40, 40, 60, 0.8);
            color: #e0e0e0;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 14px;
            margin-left: 10px;
            outline: none;
            transition: all 0.3s ease;
        }

        .setting-item input[type="time"]:focus {
            border-color: rgba(74, 144, 226, 0.5);
            box-shadow: 0 0 10px rgba(74, 144, 226, 0.3);
        }

        .setting-item label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            color: #e0e0e0;
            min-width: 150px;
        }

        .setting-item {
            margin: 15px 0;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .setting-item .btn-small {
            margin-left: 10px;
            font-size: 11px;
            padding: 4px 8px;
        }

        .setting-item input[type="range"] {
            width: 150px;
            margin: 0 10px;
            background: transparent;
            outline: none;
            -webkit-appearance: none;
        }

        .setting-item input[type="range"]::-webkit-slider-track {
            background: rgba(40, 40, 60, 0.8);
            height: 6px;
            border-radius: 3px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .setting-item input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: linear-gradient(45deg, #4a90e2, #357abd);
            cursor: pointer;
            border: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        }

        .setting-item input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(74, 144, 226, 0.4);
        }

        .setting-item input[type="range"]::-moz-range-track {
            background: rgba(40, 40, 60, 0.8);
            height: 6px;
            border-radius: 3px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .setting-item input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: linear-gradient(45deg, #4a90e2, #357abd);
            cursor: pointer;
            border: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        #volumeDisplay {
            color: #4a90e2;
            font-weight: 600;
            font-size: 12px;
            min-width: 35px;
            text-align: center;
        }


        .release-notes {
            background: rgba(40, 40, 60, 0.5);
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: rgba(40, 40, 60, 0.5);
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #4a90e2, #357abd);
            width: 0%;
            transition: width 0.3s ease;
        }

        #progressText {
            text-align: center;
            margin: 10px 0 0 0;
            font-size: 0.9em;
            color: #b0b0b0;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-left">
            <h1>üèõÔ∏è Egyptian Exchange Stocks</h1>
            <p>Real-time stock data from web scraping</p>
            <div class="market-status">
                <span id="marketStatus" class="market-status-indicator">üìä Loading...</span>
                <span id="marketCountdown" class="market-countdown" style="display: none;"></span>
            </div>
            <div class="record-counter">
                <span id="recordCount">üìä Loading...</span>
                <div id="loadingSpinner" class="loading-spinner" style="display: none;"></div>
            </div>
            <div class="controls">
                <button class="btn news-icon-btn" onclick="toggleNewsModal()" id="newsIconBtn">
                    üì∞ <span id="newsNotificationDot" class="news-notification-dot" style="display: none;"></span>
                </button>
                <button class="btn" onclick="refreshQueriesAndData(true)">üîÑ Refresh</button>
                <button class="btn" onclick="showSettingsModal()">‚öôÔ∏è Settings</button>
            </div>
        </div>
        <div class="header-right">
            <!-- Timestamp removed to avoid duplication -->
        </div>
        <div id="status" class="status" style="display: none;"></div>
    </div>

    <div class="container main-content">
        <div class="tabs">
            <button class="tab active" onclick="switchTab('all-stocks')">üìà All Stocks</button>
            <button class="tab" onclick="switchTab('watchlist')">‚≠ê Watchlist</button>
            <button class="tab" onclick="switchTab('wallet')">üí∞ Wallet</button>
            <button class="tab" onclick="switchTab('exchange-news')">üì∞ Exchange News</button>
        </div>

        <!-- All Stocks Tab -->
        <div id="all-stocks" class="tab-content active">
            <div class="search-container">
                <input type="text" id="searchInput" class="search-input" placeholder="Search stocks..." onkeyup="filterStocks()">
            </div>

            <div class="stocks-table">
                <div class="table-header">
                    üìà Live Stock Data
                </div>
                <div class="table-container">
                    <div id="loading" class="loading">
                        <div class="spinner"></div>
                        Loading stock data...
                    </div>
                    <table id="stocksTable" style="display: none;">
                        <thead>
                            <tr id="tableHeaders"></tr>
                        </thead>
                        <tbody id="stocksTableBody"></tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Watchlist Tab -->
        <div id="watchlist" class="tab-content">
            <div class="search-container">
                <input type="text" id="watchlistSearchInput" class="search-input" placeholder="Search watchlist..." onkeyup="filterWatchlist()">
            </div>

            <div class="stocks-table">
                <div class="table-header">
                    ‚≠ê My Watchlist
                </div>
                <div class="table-container">
                    <div id="watchlistLoading" class="loading" style="display: none;">
                        <div class="spinner"></div>
                        Loading watchlist...
                    </div>
                    <table id="watchlistTable" style="display: none;">
                        <thead>
                            <tr id="watchlistHeaders"></tr>
                        </thead>
                        <tbody id="watchlistTableBody"></tbody>
                    </table>
                    <div id="emptyWatchlist" class="loading">
                        <p>‚≠ê Your watchlist is empty</p>
                        <p>Add stocks from the "All Stocks" tab to start watching!</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Wallet Tab -->
        <div id="wallet" class="tab-content">
            <div class="wallet-header">
                <div style="margin-bottom: 20px;">
                    <h2 style="color: white; margin: 0;">üí∞ Portfolio</h2>
                </div>
                <div class="portfolio-summary">
                    <div class="summary-card">
                        <h3>üí∞ Portfolio Summary</h3>
                        <div class="summary-stats">
                            <div class="stat">
                                <span class="stat-label">Total Investment:</span>
                                <span id="totalInvestment" class="stat-value">EGP 0.00</span>
                            </div>
                            <div class="stat">
                                <span class="stat-label">Current Value:</span>
                                <span id="currentValue" class="stat-value">EGP 0.00</span>
                            </div>
                            <div class="stat">
                                <span class="stat-label">Total P&L:</span>
                                <span id="totalPnL" class="stat-value">EGP 0.00</span>
                            </div>
                            <div class="stat">
                                <span class="stat-label">P&L %:</span>
                                <span id="totalPnLPercent" class="stat-value">0.00%</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- All-Time Investment Summary -->
                <div class="portfolio-summary" style="margin-top: 20px;">
                    <div class="summary-card">
                        <h3>üìä All-Time Investment Summary</h3>
                        <div class="summary-stats">
                            <div class="stat">
                                <span class="stat-label">All-Time Investment:</span>
                                <span id="allTimeInvestment" class="stat-value">EGP 0.00</span>
                            </div>
                            <div class="stat">
                                <span class="stat-label">All-Time Sales:</span>
                                <span id="allTimeSales" class="stat-value">EGP 0.00</span>
                            </div>
                            <div class="stat">
                                <span class="stat-label">Net Investment:</span>
                                <span id="netInvestment" class="stat-value">EGP 0.00</span>
                            </div>
                            <div class="stat">
                                <span class="stat-label">All-Time P&L:</span>
                                <span id="allTimePnL" class="stat-value">EGP 0.00</span>
                            </div>
                        </div>
                    </div>
                </div>
                
            </div>

            <div class="search-container">
                <input type="text" id="walletSearchInput" class="search-input" placeholder="Search portfolio..." onkeyup="filterPortfolio()">
            </div>

            <div class="stocks-table">
                <div class="table-header">
                    üí∞ My Portfolio
                </div>
                <div class="table-container">
                    <div id="walletLoading" class="loading" style="display: none;">
                        <div class="spinner"></div>
                        Loading portfolio...
                    </div>
                    <table id="walletTable" style="display: none;">
                        <thead>
                            <tr id="walletHeaders">
                                <th>Stock Name</th>
                                <th>Shares</th>
                                <th>Avg Price</th>
                                <th>Total Buy Price</th>
                                <th>Current Price</th>
                                <th>Current Value</th>
                                <th>P&L</th>
                                <th>P&L %</th>
                                <th>Action</th>
                            </tr>
                        </thead>
                        <tbody id="walletTableBody"></tbody>
                    </table>
                    <div id="emptyWallet" class="loading">
                        <p>üí∞ Your portfolio is empty</p>
                        <p>Add stocks to start tracking your investments!</p>
                    </div>
                </div>
            </div>

            <!-- Transaction History Button -->
            <div style="margin-top: 30px; text-align: center;">
                <button class="btn" onclick="showTransactionHistoryModal()" style="background: linear-gradient(135deg, #3498db, #2980b9); border: 1px solid #3498db; padding: 15px 30px; font-size: 16px;">
                    üìä View Transaction History
                </button>
            </div>
        </div>
        
        <!-- Exchange News Tab -->
        <div id="exchange-news" class="tab-content">
          <div class="exchange-news-container">
              <div class="exchange-news-header">
                 <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                     <h2 style="color: white; margin: 0; font-size: 1.2em; font-weight: 600;">üì∞ Egyptian Exchange Announcements</h2>
                     <button class="btn" onclick="refreshExchangeNews()" id="refreshExchangeNewsBtn">üîÑ Refresh</button>
                 </div>
                 <div class="exchange-news-info" style="margin: 0;">
                     <p style="color: rgba(255, 255, 255, 0.7); margin: 0; font-size: 0.8em; line-height: 1.3;">
                         üì° Live announcements from the Egyptian Exchange ‚Ä¢ Updated from <a href="https://www.mubasher.info/news/eg/now/announcements" target="_blank" style="color: #4a90e2; text-decoration: none;">Mubasher.info</a>
                     </p>
                 </div>
              </div>

              <div id="exchangeNewsLoading" class="loading" style="padding: 20px;">
                  <div class="spinner"></div>
                  Loading exchange announcements...
              </div>
              
              <div id="exchangeNewsContent" style="display: none;">
                  <div id="exchangeNewsList" class="exchange-news-list"></div>
              </div>
              
              <div id="exchangeNewsError" class="error" style="display: none;">
                  <p>‚ùå Failed to load exchange announcements</p>
                  <p>Please check your internet connection and try again.</p>
                  <button class="btn" onclick="refreshExchangeNews()">üîÑ Retry</button>
              </div>
              
              <div id="exchangeNewsEmpty" class="error" style="display: none;">
                  <p>üì∞ No announcements available</p>
                  <p>Check back later for new exchange updates!</p>
              </div>
          </div>
      </div>
        
        <div class="last-updated" id="lastUpdated"></div>
    </div>

    <!-- News Modal -->
    <div id="newsModal" class="modal" style="display: none;">
        <div class="modal-content news-modal-content">
            <div class="modal-header">
                <h2>üì∞ Market News & Updates</h2>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <button class="btn btn-small" onclick="refreshNews()" id="refreshNewsBtn">üîÑ</button>
                    <button class="close-btn" onclick="hideNewsModal()">&times;</button>
                </div>
            </div>
            <div class="modal-body news-modal-body">
                <div class="news-container">
                    <div id="newsLoading" class="loading">
                        <div class="spinner"></div>
                        Loading news...
                    </div>
                    
                    <div id="newsContent" style="display: none;">
                        <div id="newsList" class="news-list"></div>
                    </div>
                    
                    <div id="newsError" class="loading" style="display: none;">
                        <p>‚ùå Failed to load news</p>
                        <p>Please check your internet connection and try again.</p>
                        <button class="btn" onclick="refreshNews()">üîÑ Retry</button>
                    </div>
                    
                    <div id="newsEmpty" class="loading" style="display: none;">
                        <p>üì∞ No news available</p>
                        <p>Check back later for market updates!</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Column Toggle UI -->
    <button class="column-toggle-toggle" id="columnToggleBtn" onclick="toggleColumnPanel()">‚öôÔ∏è</button>
    <div class="column-toggle hidden" id="columnTogglePanel">
        <h3>üìä Column Visibility</h3>
        <div id="columnToggleList"></div>
    </div>

    <!-- Update Available Modal -->
    <div id="updateModal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üîÑ Update Available</h2>
                <button class="close-btn" onclick="hideUpdateModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div id="updateInfo">
                    <p><strong>Version:</strong> <span id="updateVersion"></span></p>
                    <p><strong>Release Notes:</strong></p>
                    <div id="updateReleaseNotes" class="release-notes"></div>
                    <p><strong>Release Date:</strong> <span id="updateReleaseDate"></span></p>
                </div>
            </div>
            <div class="modal-footer">
                <button id="downloadUpdateBtn" class="btn" onclick="openDownloadPage()">üì• Download</button>
                <button class="btn btn-secondary" onclick="hideUpdateModal()">Later</button>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h2>‚öôÔ∏è Settings</h2>
                <button class="close-btn" onclick="hideSettingsModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="setting-item">
                    <label>
                        <input type="checkbox" id="autoUpdateEnabled">
                        Enable automatic updates
                    </label>
                </div>
                <div class="setting-item">
                    <label>
                        <input type="checkbox" id="minimizeToTray">
                        Minimize to system tray
                    </label>
                </div>
                <div class="setting-item">
                    <label>
                        <input type="checkbox" id="closeToTray">
                        Close to system tray
                    </label>
                </div>
                <div class="setting-item">
                    <label>
                        <input type="checkbox" id="playNotification">
                        Play Notification
                    </label>
                    <button class="btn btn-small" onclick="testNotificationSound()" id="testSoundBtn">üîä Test Sound</button>
                </div>
                <div class="setting-item">
                    <label for="notificationVolume">Notification Volume:</label>
                    <input type="range" id="notificationVolume" min="0" max="1" step="0.1" value="0.7">
                    <span id="volumeDisplay">70%</span>
                </div>
                <div class="setting-item">
                    <label for="marketOpenTime">Market Open Time:</label>
                    <input type="time" id="marketOpenTime" value="10:00">
                </div>
                <div class="setting-item">
                    <label for="marketCloseTime">Market Close Time:</label>
                    <input type="time" id="marketCloseTime" value="14:30">
                </div>
                <div class="setting-item">
                    <label for="updateInterval">Data Update Interval (seconds):</label>
                    <input type="number" id="updateInterval" min="5" max="300" step="5" value="30" style="width: 80px; margin-right: 10px;">
                    <span id="intervalDisplay">30 seconds</span>
                </div>
                <div class="setting-item" style="flex-direction: column; align-items: flex-start; margin: 20px 0;">
                    <label style="margin-bottom: 10px; font-weight: 600; color: #ffffff;">Days Off (Market Closed):</label>
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; width: 100%;">
                        <div class="setting-item" style="margin: 5px 0;">
                            <label>
                                <input type="checkbox" id="sundayOff">
                                Sunday
                            </label>
                        </div>
                        <div class="setting-item" style="margin: 5px 0;">
                            <label>
                                <input type="checkbox" id="mondayOff">
                                Monday
                            </label>
                        </div>
                        <div class="setting-item" style="margin: 5px 0;">
                            <label>
                                <input type="checkbox" id="tuesdayOff">
                                Tuesday
                            </label>
                        </div>
                        <div class="setting-item" style="margin: 5px 0;">
                            <label>
                                <input type="checkbox" id="wednesdayOff">
                                Wednesday
                            </label>
                        </div>
                        <div class="setting-item" style="margin: 5px 0;">
                            <label>
                                <input type="checkbox" id="thursdayOff">
                                Thursday
                            </label>
                        </div>
                        <div class="setting-item" style="margin: 5px 0;">
                            <label>
                                <input type="checkbox" id="fridayOff">
                                Friday
                            </label>
                        </div>
                        <div class="setting-item" style="margin: 5px 0;">
                            <label>
                                <input type="checkbox" id="saturdayOff">
                                Saturday
                            </label>
                        </div>
                    </div>
                </div>
                <div class="setting-item" style="flex-direction: column; align-items: flex-start; margin: 20px 0;">
                    <label style="margin-bottom: 10px; font-weight: 600; color: #ffffff;">Widget Window:</label>
                    <div class="setting-item" style="margin: 5px 0;">
                        <label>
                            <input type="checkbox" id="widgetEnabled">
                            Enable Widget Window
                        </label>
                    </div>
                    <div class="setting-item" style="margin: 5px 0;">
                        <label>
                            <input type="checkbox" id="widgetAlwaysOnTop">
                            Always on Top
                        </label>
                    </div>
                    <div class="setting-item" style="margin: 5px 0;">
                        <label for="widgetOpacity">Opacity:</label>
                        <input type="range" id="widgetOpacity" min="0.3" max="1" step="0.1" value="0.9" style="width: 100px; margin: 0 10px;">
                        <span id="widgetOpacityDisplay">90%</span>
                    </div>
                    <div class="setting-item" style="margin: 10px 0;">
                        <button class="btn btn-small" onclick="toggleWidgetWindow()" id="toggleWidgetBtn">üìä Toggle Widget</button>
                    </div>
                </div>
                <div class="setting-item" style="flex-direction: column; align-items: flex-start; margin: 20px 0;">
                    <label style="margin-bottom: 10px; font-weight: 600; color: #ffffff;">üíæ Wallet Data Backup & Restore:</label>
                    <div style="display: flex; gap: 10px; width: 100%; flex-wrap: wrap;">
                        <button class="btn" onclick="backupWalletData()" id="backupBtn">üíæ Backup Wallet Data</button>
                        <button class="btn" onclick="restoreWalletData()" id="restoreBtn">üì• Restore Wallet Data</button>
                    </div>
                    <input type="file" id="restoreFileInput" accept=".json" style="display: none;" onchange="handleRestoreFile(event)">
                    <p style="font-size: 12px; color: #888; margin-top: 10px; line-height: 1.4;">
                        Backup includes: Portfolio holdings and Transaction history.<br>
                        Restore will replace current wallet data with backup data.
                    </p>
                </div>
                
                <div class="setting-item">
                    <button class="btn" onclick="checkForUpdates()" id="checkUpdateBtn">üîç Check for Updates</button>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="saveSettings()">üíæ Save Settings</button>
                <button class="btn btn-secondary" onclick="hideSettingsModal()">Cancel</button>
            </div>
            <div style="
                padding: 10px 20px;
                background: rgba(20, 20, 40, 0.5);
                border-top: 1px solid rgba(255, 255, 255, 0.1);
                text-align: center;
                font-size: 0.75em;
                color: #888;
            ">
                <p>The Egyptian Exchange App v<span id="settingsAppVersion">0.9.2</span> - Developed by <a href="https://github.com/AMoussa77/The-Egyptian-Exchange/releases" target="_blank" style="color: #4a90e2; text-decoration: none;">A Moussa</a></p>
            </div>
        </div>
    </div>

    <!-- Add Stock to Portfolio Modal -->
    <div id="addStockModal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3>‚ûï Add Stock to Portfolio</h3>
                <button class="btn btn-small" onclick="hideAddStockModal()">‚úï</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="stockSelect">Select Stock:</label>
                    <select id="stockSelect" class="form-input" onchange="updateStockInfo()">
                        <option value="">Choose a stock...</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="sharesInput">Number of Shares:</label>
                    <input type="number" id="sharesInput" class="form-input" placeholder="Enter number of shares" min="1" step="1">
                </div>
                <div class="form-group">
                    <label for="buyPriceInput">Buy Price (EGP):</label>
                    <input type="number" id="buyPriceInput" class="form-input" placeholder="Enter your desired buy price per share" min="0" step="any">
                </div>
                <div class="form-group">
                    <label for="buyDateInput">Buy Date:</label>
                    <input type="date" id="buyDateInput" class="form-input">
                </div>
                <div class="stock-info" id="stockInfo" style="display: none;">
                    <h4>Stock Information:</h4>
                    <div class="info-item">
                        <span class="info-label">Current Price:</span>
                        <span id="currentPriceDisplay" class="info-value">-</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Change:</span>
                        <span id="changeDisplay" class="info-value">-</span>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="addStockToPortfolio()">‚ûï Add to Portfolio</button>
                <button class="btn btn-secondary" onclick="hideAddStockModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Buy Stock Modal -->
    <div id="buyStockModal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3>üí∞ Buy Stock</h3>
                <button class="btn btn-small" onclick="hideBuyStockModal()">‚úï</button>
            </div>
            <div id="buyModalValidation" class="modal-validation" style="display: none; padding: 10px; margin: 10px 20px; border-radius: 5px; background: rgba(231, 76, 60, 0.2); border: 1px solid #e74c3c; color: #e74c3c; font-size: 14px;"></div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="buyStockName">Stock:</label>
                    <input type="text" id="buyStockName" class="form-input" readonly>
                </div>
                <div class="form-group">
                    <label for="buySharesInput">Number of Shares:</label>
                    <input type="number" id="buySharesInput" class="form-input" placeholder="Enter number of shares" min="1" step="1">
                </div>
                <div class="form-group">
                    <label for="buyModalPriceInput">Buy Price (EGP):</label>
                    <input type="number" id="buyModalPriceInput" class="form-input" placeholder="Enter your desired buy price per share" min="0" step="any">
                </div>
                <div class="form-group">
                    <label for="buyModalDateInput">Buy Date:</label>
                    <input type="date" id="buyModalDateInput" class="form-input">
                </div>
                <div class="stock-info" id="buyStockInfo" style="display: none;">
                    <h4>Current Stock Information:</h4>
                    <div class="info-item">
                        <span class="info-label">Current Price:</span>
                        <span id="buyCurrentPriceDisplay" class="info-value">-</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Change:</span>
                        <span id="buyChangeDisplay" class="info-value">-</span>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="confirmBuyStock()">üí∞ Buy Stock</button>
                <button class="btn btn-secondary" onclick="hideBuyStockModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Sell Stock Modal -->
    <div id="sellStockModal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3>üí∏ Sell Stock</h3>
                <button class="btn btn-small" onclick="hideSellStockModal()">‚úï</button>
            </div>
            <div id="sellModalValidation" class="modal-validation" style="display: none; padding: 10px; margin: 10px 20px; border-radius: 5px; background: rgba(231, 76, 60, 0.2); border: 1px solid #e74c3c; color: #e74c3c; font-size: 14px;"></div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="sellStockName">Stock:</label>
                    <input type="text" id="sellStockName" class="form-input" readonly>
                </div>
                <div class="form-group">
                    <label for="sellSharesInput">Number of Shares to Sell:</label>
                    <input type="number" id="sellSharesInput" class="form-input" placeholder="Enter number of shares" min="1" step="1">
                    <small style="color: #b0b0b0;">Max: <span id="sellMaxShares">0</span> shares</small>
                </div>
                <div class="form-group">
                    <label for="sellPriceInput">Sell Price (EGP):</label>
                    <input type="number" id="sellPriceInput" class="form-input" placeholder="Enter sell price per share" min="0" step="any">
                </div>
                <div class="form-group">
                    <label for="sellDateInput">Sell Date:</label>
                    <input type="date" id="sellDateInput" class="form-input">
                </div>
                <div class="stock-info" id="sellStockInfo" style="display: none;">
                    <h4>Current Stock Information:</h4>
                    <div class="info-item">
                        <span class="info-label">Current Price:</span>
                        <span id="sellCurrentPriceDisplay" class="info-value">-</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Change:</span>
                        <span id="sellChangeDisplay" class="info-value">-</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Your Shares:</span>
                        <span id="sellYourSharesDisplay" class="info-value">-</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Average Buy Price:</span>
                        <span id="sellAvgPriceDisplay" class="info-value">-</span>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-watchlist" onclick="confirmSellStock()">üí∏ Sell Stock</button>
                <button class="btn btn-secondary" onclick="hideSellStockModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Transaction History Modal -->
    <div id="transactionHistoryModal" class="modal" style="display: none;">
        <div class="modal-content" style="max-width: 900px;">
            <div class="modal-header">
                <h3>üìä Transaction History</h3>
                <button class="btn btn-small" onclick="hideTransactionHistoryModal()">‚úï</button>
            </div>
            <div id="transactionModalValidation" class="modal-validation" style="display: none; padding: 10px; margin: 10px 20px; border-radius: 5px; background: rgba(46, 204, 113, 0.2); border: 1px solid #2ecc71; color: #27ae60; font-size: 14px;"></div>
            <div class="modal-body" style="padding: 0;">
                <div style="padding: 20px; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid rgba(255, 255, 255, 0.1);">
                    <h4 style="color: #e0e0e0; margin: 0;">All Transactions</h4>
                    <button class="btn btn-secondary" onclick="clearTransactionHistoryModal()" style="background: rgba(231, 76, 60, 0.8); border: 1px solid #e74c3c;">
                        üóëÔ∏è Clear All
                    </button>
                </div>
                <div style="max-height: 400px; overflow-y: auto; padding: 20px;">
                    <div id="modalTransactionLoading" class="loading" style="display: none;">
                        <div class="spinner"></div>
                        Loading transaction history...
                    </div>
                    <table id="modalTransactionTable" style="display: none; width: 100%;">
                        <thead>
                            <tr>
                                <th>Date</th>
                                <th>Stock</th>
                                <th>Type</th>
                                <th>Shares</th>
                                <th>Price</th>
                                <th>Total</th>
                            </tr>
                        </thead>
                        <tbody id="modalTransactionTableBody"></tbody>
                    </table>
                    <div id="modalEmptyTransactions" class="loading">
                        <p>üìä No transaction history</p>
                        <p>Buy or sell stocks to see your transaction history!</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Clear Transaction Confirmation Modal -->
    <div id="clearTransactionConfirmModal" class="modal" style="display: none;">
        <div class="modal-content" style="max-width: 450px; animation: modalSlideIn 0.3s ease-out;">
            <div class="modal-header" style="background: linear-gradient(135deg, #e74c3c, #c0392b);">
                <h3 style="display: flex; align-items: center; gap: 10px;">
                    <span style="font-size: 24px;">‚ö†Ô∏è</span>
                    Clear Transaction History
                </h3>
                <button class="btn btn-small" onclick="hideClearTransactionConfirmModal()">‚úï</button>
            </div>
            <div class="modal-body" style="padding: 30px 20px;">
                <div style="text-align: center; margin-bottom: 25px;">
                    <div style="font-size: 48px; margin-bottom: 15px;">üóëÔ∏è</div>
                    <h4 style="color: #e0e0e0; margin-bottom: 15px;">Are you sure?</h4>
                    <p style="color: #b0b0b0; line-height: 1.6; margin: 0;">
                        This will permanently delete all your transaction history. 
                        <br><strong style="color: #e74c3c;">This action cannot be undone.</strong>
                    </p>
                </div>
            </div>
            <div class="modal-footer" style="padding: 15px 20px; display: flex; gap: 10px; justify-content: flex-end; background: rgba(20, 20, 40, 0.3);">
                <button class="btn btn-secondary" onclick="hideClearTransactionConfirmModal()" style="background: rgba(108, 117, 125, 0.8); border: 1px solid #6c757d;">
                    Cancel
                </button>
                <button class="btn" onclick="confirmClearTransactionHistory()" style="background: linear-gradient(135deg, #e74c3c, #c0392b); border: 1px solid #e74c3c;">
                    üóëÔ∏è Clear All
                </button>
            </div>
        </div>
    </div>

    <!-- Restore Confirmation Modal -->
    <div id="restoreConfirmModal" class="modal" style="display: none;">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
                <h3>üì• Restore Wallet Data</h3>
                <button class="close-btn" onclick="hideRestoreConfirmModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div style="background: rgba(255, 193, 7, 0.1); border: 1px solid rgba(255, 193, 7, 0.3); border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                    <div style="display: flex; align-items: center; margin-bottom: 10px;">
                        <span style="font-size: 24px; margin-right: 10px;">‚ö†Ô∏è</span>
                        <strong style="color: #ffc107;">Warning: This will replace your current data</strong>
                    </div>
                    <p style="margin: 0; color: #fff3cd; font-size: 14px;">
                        Your current portfolio and transaction history will be permanently replaced with the backup data.
                    </p>
                </div>
                
                <div style="background: rgba(40, 167, 69, 0.1); border: 1px solid rgba(40, 167, 69, 0.3); border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0; color: #28a745; display: flex; align-items: center;">
                        <span style="margin-right: 8px;">üìä</span>
                        Backup File Contents:
                    </h4>
                    <div id="restoreBackupInfo" style="color: #d4edda;">
                        <!-- Backup info will be populated here -->
                    </div>
                </div>
                
                <div style="background: rgba(220, 53, 69, 0.1); border: 1px solid rgba(220, 53, 69, 0.3); border-radius: 8px; padding: 15px;">
                    <h4 style="margin: 0 0 10px 0; color: #dc3545; display: flex; align-items: center;">
                        <span style="margin-right: 8px;">üóëÔ∏è</span>
                        Current Data (will be lost):
                    </h4>
                    <div id="restoreCurrentInfo" style="color: #f8d7da;">
                        <!-- Current info will be populated here -->
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="confirmRestore()" id="confirmRestoreBtn" style="background: linear-gradient(45deg, #28a745, #20c997); border: none;">
                    üì• Yes, Restore Data
                </button>
                <button class="btn btn-secondary" onclick="hideRestoreConfirmModal()">
                    ‚ùå Cancel
                </button>
            </div>
        </div>
    </div>

    <script>
        const { ipcRenderer } = require('electron');
        let allStocks = [];
        let filteredStocks = [];
        let watchlist = [];
        let filteredWatchlist = [];
        let portfolio = [];
        let filteredPortfolio = [];
        let transactions = [];
        let currentSearchTerm = '';
        let currentWatchlistSearchTerm = '';
        let currentWalletSearchTerm = '';
        let currentSortColumn = '';
        let currentSortDirection = '';
        let watchlistSortColumn = '';
        let watchlistSortDirection = '';
        let columnVisibility = {};
        let availableColumns = [];
        let currentMarketStatus = { status: 'loading', isDayOff: false };
        let startupRetryCount = 0;
        let isStartupPhase = true;
        let startupRetryTimer = null;
        let manualRefreshRetryCount = 0;
        let isManualRefreshRetrying = false;
        let manualRefreshRetryTimer = null;

        // Load initial data
        window.addEventListener('DOMContentLoaded', async () => {
            loadColumnVisibility();
            loadWatchlist();
            loadPortfolio();
            loadAppVersion();
            loadCachedNews(); // Load cached news immediately
            loadCachedExchangeNews(); // Load cached exchange news
            
            // Load fresh news once at startup
            setTimeout(() => {
                console.log('üì∞ Loading fresh news at startup...');
                loadNews(true); // Force load fresh news from sources
            }, 2000); // Load after other initialization
            
            // Start countdown timer
            setInterval(() => {
                if (currentMarketStatus && currentMarketStatus.status === 'closed') {
                    updateCountdownDisplay();
                }
            }, 1000); // Update countdown every second
            
            // Trigger initial data load that overrides market status (like manual refresh)
            console.log('üöÄ App startup - requesting initial data (overriding market status)');
            setTimeout(() => {
                startupDataLoad(); // Use dedicated startup function with retry logic
            }, 1000); // Small delay to ensure everything is initialized
            
            startAutoRefresh();
            setupVolumeSlider();
            setupUpdateInterval();
            setupWidgetOpacitySlider();
            
            // Setup widget enabled checkbox
            setupWidgetEnabledCheckbox();
            
            // Initialize market status indicator
            updateMarketStatusIndicator({ status: 'loading' });
            
            // Set a fallback timeout to ensure market status updates
            setTimeout(() => {
                const marketStatusElement = document.getElementById('marketStatus');
                if (marketStatusElement && marketStatusElement.textContent.includes('Loading')) {
                    console.log('‚ö†Ô∏è Market status still loading, applying fallback...');
                    // Apply a basic market status check as fallback
                    const now = new Date();
                    const currentHour = now.getHours();
                    const currentMinute = now.getMinutes();
                    const currentTime = currentHour * 60 + currentMinute;
                    const openTime = 10 * 60; // 10:00 AM
                    const closeTime = 14 * 60 + 30; // 2:30 PM
                    
                    let fallbackStatus = 'closed';
                    if (currentTime >= openTime && currentTime < closeTime) {
                        fallbackStatus = 'open';
                    }
                    
                    updateMarketStatusIndicator({ 
                        status: fallbackStatus,
                        isDayOff: false,
                        currentDay: 'unknown'
                    });
                }
            }, 3000); // 3 second fallback
            
            // Wait a bit for DOM to be fully ready
            setTimeout(() => {
                // Show column toggles even without data
                updateColumnToggleUI();
                // Initialize table structure with default columns
                initializeTableStructure();
            }, 100);
        });

        // Listen for data-ready signal from main process
        ipcRenderer.on('data-ready', async () => {
            console.log('üìä Data ready signal received, waiting for stock data...');
            // Don't call loadStockData here - wait for stock-data-updated event
        });

        async function loadStockData(isManualOrStartup = false) {
            try {
                if (isManualOrStartup) {
                    console.log('üîÑ Requesting stock data from main process (manual/startup override)...');
                } else {
                console.log('üîÑ Requesting stock data from main process...');
                }
                const data = await ipcRenderer.invoke('get-stock-data');
                console.log('üìä Received data:', data ? data.length : 0, 'stocks');
                console.log('üìä Data type:', typeof data);
                console.log('üìä Is array:', Array.isArray(data));
                if (data && data.length > 0) {
                    console.log('üìä Sample data:', data[0]);
                }
                
                if (data && data.length > 0) {
                    // Check if we have mock data (2 records) - NEVER load mock data
                    if (data.length === 2) {
                        console.log('‚ö†Ô∏è Mock data detected (2 records) - not loading mock data');
                        // Just update the record counter to show the warning
                        updateRecordCounter();
                        return;
                    }
                    
                    // Normal data - update as usual
                    allStocks = data;
                    // Preserve current search filter
                    if (currentSearchTerm) {
                        filteredStocks = allStocks.filter(stock => {
                            return Object.values(stock).some(value => 
                                String(value).toLowerCase().includes(currentSearchTerm.toLowerCase())
                            );
                        });
                    } else {
                        filteredStocks = [...allStocks];
                    }
                    
                    // Reapply sorting if there's an active sort
                    if (currentSortColumn) {
                        filteredStocks = sortData([...filteredStocks], currentSortColumn, currentSortDirection);
                    }
                    
                    initializeColumnVisibility();
                    displayStocks();
                    updateLastUpdated();
                    updateRecordCounter();
                } else {
                    showStatus('No stock data available. Please check your internet connection.', 'error');
                }
            } catch (error) {
                console.error('Error loading stock data:', error);
                showStatus('Error loading stock data: ' + error.message, 'error');
            }
        }

        function loadWatchlist() {
            const savedWatchlist = localStorage.getItem('egyptianStocksWatchlist');
            if (savedWatchlist) {
                try {
                    watchlist = JSON.parse(savedWatchlist);
                    filteredWatchlist = [...watchlist];
                    
                    // Reapply sorting if there's an active sort
                    if (watchlistSortColumn) {
                        filteredWatchlist = sortData([...filteredWatchlist], watchlistSortColumn, watchlistSortDirection);
                    }
                    
                    displayWatchlist();
                    console.log('Watchlist loaded:', watchlist.length, 'stocks');
                } catch (error) {
                    console.error('Error loading watchlist:', error);
                    watchlist = [];
                    filteredWatchlist = [];
                }
            } else {
                watchlist = [];
                filteredWatchlist = [];
            }
        }

        function saveWatchlist() {
            try {
                localStorage.setItem('egyptianStocksWatchlist', JSON.stringify(watchlist));
                console.log('Watchlist saved:', watchlist.length, 'stocks');
                sendWatchlistToWidget(); // Send to widget when watchlist is saved
            } catch (error) {
                console.error('Error saving watchlist:', error);
            }
        }

        function validateAndFixPortfolioData(portfolioData) {
            console.log('üîç Validating portfolio data...');
            
            return portfolioData.map(item => {
                console.log(`üîç Validating item: ${item.stockName}`, item);
                
                // Ensure buyPrice is a number and not corrupted
                if (typeof item.buyPrice !== 'number' || item.buyPrice <= 0) {
                    console.warn(`‚ö†Ô∏è Invalid buyPrice for ${item.stockName}: ${item.buyPrice}, setting to 0`);
                    item.buyPrice = 0;
                }
                
                // Ensure shares is a number
                if (typeof item.shares !== 'number' || item.shares <= 0) {
                    console.warn(`‚ö†Ô∏è Invalid shares for ${item.stockName}: ${item.shares}, setting to 0`);
                    item.shares = 0;
                }
                
                // Log the calculation that will be used
                const totalBuyPrice = item.shares * item.buyPrice;
                console.log(`‚úÖ ${item.stockName}: ${item.shares} shares √ó ${item.buyPrice} = ${smartFormatPrice(totalBuyPrice)} EGP`);
                
                return item;
            });
        }

        function clearPortfolioData() {
            if (confirm('Are you sure you want to clear all portfolio data? This cannot be undone.')) {
                portfolio = [];
                filteredPortfolio = [];
                transactions = [];
                localStorage.removeItem('egyptianStocksPortfolio');
                localStorage.removeItem('egyptianStocksTransactions');
                displayPortfolio();
                displayTransactionHistory();
                updatePortfolioSummary();
                showStatus('Portfolio data cleared', 'success');
                console.log('üóëÔ∏è Portfolio data cleared');
            }
        }

        function testBuyPriceCalculation() {
            console.log('üß™ Testing buy price calculation...');
            
            // Create a test portfolio item
            const testItem = {
                stockName: 'TEST_STOCK',
                shares: 5,
                buyPrice: 2.0,
                buyDate: '2024-01-01'
            };
            
            console.log('Test item:', testItem);
            console.log('Expected Total Buy Price: 5 √ó 2.0 = 10.0');
            console.log('Calculated Total Buy Price:', testItem.shares * testItem.buyPrice);
            
            // Test with the actual portfolio if it exists
            if (portfolio.length > 0) {
                console.log('üîç Testing with actual portfolio data:');
                portfolio.forEach((item, index) => {
                    console.log(`Item ${index + 1}: ${item.stockName}`);
                    console.log(`  shares: ${item.shares} (type: ${typeof item.shares})`);
                    console.log(`  buyPrice: ${item.buyPrice} (type: ${typeof item.buyPrice})`);
                    console.log(`  calculated total: ${item.shares * item.buyPrice}`);
                    console.log('  ---');
                });
            }
            
            // Check what's in localStorage
            const savedData = localStorage.getItem('egyptianStocksPortfolio');
            if (savedData) {
                console.log('üìÅ Raw data in localStorage:', savedData);
                try {
                    const parsed = JSON.parse(savedData);
                    console.log('üìÅ Parsed data:', parsed);
                } catch (e) {
                    console.error('üìÅ Error parsing localStorage data:', e);
                }
            }
        }

        function loadPortfolio() {
            const savedPortfolio = localStorage.getItem('egyptianStocksPortfolio');
            const savedTransactions = localStorage.getItem('egyptianStocksTransactions');
            
            if (savedPortfolio) {
                try {
                    portfolio = JSON.parse(savedPortfolio);
                    
                    // Validate and fix portfolio data
                    portfolio = validateAndFixPortfolioData(portfolio);
                    
                    filteredPortfolio = [...portfolio];
                    console.log('Portfolio loaded:', portfolio.length, 'stocks');
                    console.log('Portfolio data:', portfolio);
                    updatePortfolioSummary();
                    displayPortfolio();
                } catch (error) {
                    console.error('Error loading portfolio:', error);
                    portfolio = [];
                    filteredPortfolio = [];
                }
            } else {
                portfolio = [];
                filteredPortfolio = [];
            }
            
            // Load transactions
            if (savedTransactions) {
                try {
                    transactions = JSON.parse(savedTransactions);
                    displayTransactionHistory();
                    console.log('Transactions loaded:', transactions.length, 'transactions');
                } catch (error) {
                    console.error('Error loading transactions:', error);
                    transactions = [];
                }
            } else {
                transactions = [];
            }
        }

        function savePortfolio() {
            try {
                localStorage.setItem('egyptianStocksPortfolio', JSON.stringify(portfolio));
                console.log('Portfolio saved:', portfolio.length, 'stocks');
            } catch (error) {
                console.error('Error saving portfolio:', error);
            }
        }

        function saveTransactions() {
            try {
                localStorage.setItem('egyptianStocksTransactions', JSON.stringify(transactions));
                console.log('Transactions saved:', transactions.length, 'transactions');
            } catch (error) {
                console.error('Error saving transactions:', error);
            }
        }

        function loadColumnVisibility() {
            try {
                const saved = localStorage.getItem('egyptianStocksColumnVisibility');
                if (saved) {
                    columnVisibility = JSON.parse(saved);
                } else {
                    columnVisibility = {};
                }
            } catch (error) {
                console.error('Error loading column visibility:', error);
                columnVisibility = {};
            }
        }

        function saveColumnVisibility() {
            try {
                localStorage.setItem('egyptianStocksColumnVisibility', JSON.stringify(columnVisibility));
            } catch (error) {
                console.error('Error saving column visibility:', error);
            }
        }

        async function loadAppVersion() {
            try {
                // Get version from main process
                const version = await ipcRenderer.invoke('get-app-version');
                
                // Update main footer
                const mainVersionElement = document.getElementById('appVersion');
                if (mainVersionElement) {
                    mainVersionElement.textContent = version;
                }
                
                // Update settings modal footer
                const settingsVersionElement = document.getElementById('settingsAppVersion');
                if (settingsVersionElement) {
                    settingsVersionElement.textContent = version;
                }
            } catch (error) {
                console.error('Error loading app version:', error);
                // Keep default version if error occurs
            }
        }

        function initializeColumnVisibility() {
            if (allStocks.length > 0) {
                availableColumns = Object.keys(allStocks[0]);
                
                // Initialize visibility for new columns (default: visible)
                availableColumns.forEach(column => {
                    if (columnVisibility[column] === undefined) {
                        columnVisibility[column] = true;
                    }
                });
                
                // Keep saved settings for columns that don't exist in current data
                // Don't delete them as they might be from previous data structures
                // Only clean up if we're sure they're obsolete
                
                saveColumnVisibility();
                updateColumnToggleUI();
            }
        }

        function getDefaultColumns() {
            // Return the actual Arabic column names used in Egyptian Exchange data
            return [
                'ÿ£ŸÇÿµŸâ_ÿ≥ÿπÿ±',      // Maximum price
                'ÿ£ÿØŸÜŸâ_ÿ≥ÿπÿ±',      // Minimum price
                'ÿ•ÿ∫ŸÑÿßŸÇ',         // Close
                'ÿ•ŸÇŸÅÿßŸÑ_ÿ≥ÿßÿ®ŸÇ',    // Previous close
                'ÿßŸÑÿ™ÿ∫Ÿäÿ±',        // Change
                '%ÿßŸÑÿ™ÿ∫ŸäŸäÿ±',      // Change %
                'ÿ£ÿπŸÑŸâ',          // High
                'ÿßŸÑÿ£ÿØŸÜŸâ',        // Low
                'ÿßŸÑÿ∑ŸÑÿ®',         // Bid/Demand
                'ÿßŸÑÿπÿ±ÿ∂',         // Offer/Supply
                'ÿ£ÿÆÿ±_ÿ≥ÿπÿ±',       // Last price
                'ÿßŸÑÿ•ÿ≥ŸÖ_ÿßŸÑŸÖÿÆÿ™ÿµÿ±', // Short name/Abbreviated name
                'ÿ≠ÿ¨ŸÖ_ÿßŸÑÿ™ÿØÿßŸàŸÑ'    // Trading volume
            ];
        }

        function initializeTableStructure() {
            // Initialize table headers with default columns even without data
            const defaultColumns = getDefaultColumns();
            const visibleColumns = defaultColumns.filter(column => columnVisibility[column] !== false);
            
            // Update All Stocks table headers
            const allStocksHeaders = document.getElementById('allStocksHeaders');
            if (allStocksHeaders) {
                allStocksHeaders.innerHTML = visibleColumns.map(header => {
                    return `
                        <th class="sortable" onclick="sortStocks('${header}')">
                            ${header}
                            <span class="sort-indicator"></span>
                        </th>
                    `;
                }).join('');
            }
            
            // Update Watchlist table headers
            const watchlistHeaders = document.getElementById('watchlistHeaders');
            if (watchlistHeaders) {
                watchlistHeaders.innerHTML = visibleColumns.map(header => {
                    return `
                        <th class="sortable" onclick="sortWatchlist('${header}')">
                            ${header}
                            <span class="sort-indicator"></span>
                        </th>
                    `;
                }).join('');
            }
            
            // Show empty state messages
            const allStocksTable = document.getElementById('allStocksTable');
            const watchlistTable = document.getElementById('watchlistTable');
            const allStocksLoading = document.getElementById('allStocksLoading');
            const watchlistLoading = document.getElementById('watchlistLoading');
            
            if (allStocksTable) allStocksTable.style.display = 'none';
            if (watchlistTable) watchlistTable.style.display = 'none';
            if (allStocksLoading) allStocksLoading.style.display = 'block';
            if (watchlistLoading) watchlistLoading.style.display = 'none';
        }

        function updateColumnToggleUI() {
            const toggleList = document.getElementById('columnToggleList');
            if (!toggleList) return;
            
            // Use availableColumns if data is loaded, otherwise use default columns
            const columnsToShow = availableColumns.length > 0 ? availableColumns : getDefaultColumns();
            
            toggleList.innerHTML = columnsToShow.map(column => {
                const isVisible = columnVisibility[column] !== false;
                return `
                    <div class="column-toggle-item">
                        <input type="checkbox" id="col-${column}" ${isVisible ? 'checked' : ''} 
                               onchange="toggleColumn('${column}', this.checked)">
                        <label for="col-${column}">${column}</label>
                    </div>
                `;
            }).join('');
        }

        function toggleColumn(column, visible) {
            columnVisibility[column] = visible;
            saveColumnVisibility();
            
            // Update table structure immediately
            if (allStocks.length > 0) {
                // If data is available, use normal display functions
                displayStocks();
                displayWatchlist();
            } else {
                // If no data yet, just update the table structure
                initializeTableStructure();
            }
        }

        function toggleColumnPanel() {
            const panel = document.getElementById('columnTogglePanel');
            const btn = document.getElementById('columnToggleBtn');
            
            if (panel.classList.contains('hidden')) {
                panel.classList.remove('hidden');
                btn.style.background = 'rgba(52, 152, 219, 0.2)';
            } else {
                panel.classList.add('hidden');
                btn.style.background = 'rgba(255, 255, 255, 0.95)';
            }
        }


        function sortData(data, column, direction) {
            return data.sort((a, b) => {
                let aVal = a[column] || '';
                let bVal = b[column] || '';
                
                // Check if values are already numbers
                if (typeof aVal === 'number' && typeof bVal === 'number') {
                    // Direct numeric comparison
                    return direction === 'asc' ? aVal - bVal : bVal - aVal;
                }
                
                // Try to parse as numbers for numeric columns
                const aNum = parseFloat(aVal);
                const bNum = parseFloat(bVal);
                
                if (!isNaN(aNum) && !isNaN(bNum)) {
                    // Numeric comparison
                    return direction === 'asc' ? aNum - bNum : bNum - aNum;
                } else {
                    // String comparison
                    aVal = String(aVal).toLowerCase();
                    bVal = String(bVal).toLowerCase();
                    
                    if (direction === 'asc') {
                        return aVal < bVal ? -1 : aVal > bVal ? 1 : 0;
                    } else {
                        return aVal > bVal ? -1 : aVal < bVal ? 1 : 0;
                    }
                }
            });
        }

        function sortStocks(column) {
            // Determine sort direction
            if (currentSortColumn === column) {
                currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                currentSortColumn = column;
                currentSortDirection = 'asc';
            }
            
            // Sort the filtered stocks
            filteredStocks = sortData([...filteredStocks], column, currentSortDirection);
            displayStocks();
        }

        function sortWatchlist(column) {
            // Determine sort direction
            if (watchlistSortColumn === column) {
                watchlistSortDirection = watchlistSortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                watchlistSortColumn = column;
                watchlistSortDirection = 'asc';
            }
            
            // Sort the filtered watchlist
            filteredWatchlist = sortData([...filteredWatchlist], column, watchlistSortDirection);
            displayWatchlist();
        }

        function displayStocks() {
            const table = document.getElementById('stocksTable');
            const tableBody = document.getElementById('stocksTableBody');
            const tableHeaders = document.getElementById('tableHeaders');
            const loading = document.getElementById('loading');

            if (filteredStocks.length === 0) {
                loading.innerHTML = '<div class="spinner"></div>No stocks found matching your search.';
                loading.style.display = 'block';
                table.style.display = 'none';
                return;
            }

            // Create headers with action column (only visible columns)
            const allHeaders = Object.keys(filteredStocks[0]);
            const visibleHeaders = allHeaders.filter(header => columnVisibility[header] !== false);
            
            tableHeaders.innerHTML = visibleHeaders.map(header => {
                let sortClass = 'sortable';
                if (currentSortColumn === header) {
                    sortClass += ` sort-${currentSortDirection}`;
                }
                return `<th class="${sortClass}" onclick="sortStocks('${header}')">${header}</th>`;
            }).join('') + '<th>Action</th>';

            // Create rows (only visible columns)
            tableBody.innerHTML = filteredStocks.map((stock, index) => {
                const row = visibleHeaders.map(header => {
                    let value = stock[header] || '';
                    let className = '';
                    let displayValue = value;
                    
                    // Format numeric values for display
                    if (typeof value === 'number' && !isNaN(value)) {
                        if (header === '%ÿßŸÑÿ™ÿ∫ŸäŸäÿ±' || header === 'Changes %') {
                            displayValue = value.toFixed(2) + '%';
                        } else if (header === 'ÿ≠ÿ¨ŸÖ_ÿßŸÑÿ™ÿØÿßŸàŸÑ') {
                            displayValue = value.toLocaleString();
                        } else {
                            displayValue = smartFormatPrice(value);
                        }
                    }
                    
                    // Style based on column content
                    if (header === 'ÿ£ÿÆÿ±_ÿ≥ÿπÿ±' || header === 'Last Price') {
                        className = 'price-neutral';
                    } else if (header === '%ÿßŸÑÿ™ÿ∫ŸäŸäÿ±' || header === 'Changes %') {
                        const numValue = typeof value === 'number' ? value : parseFloat(value);
                        if (numValue > 0) className = 'price-positive';
                        else if (numValue < 0) className = 'price-negative';
                        else className = 'price-neutral';
                    }
                    
                    return `<td class="${className}">${displayValue}</td>`;
                }).join('');
                
                // Check if stock is already in watchlist and portfolio
                const isInWatchlist = watchlist.some(w => JSON.stringify(w) === JSON.stringify(stock));
                const stockName = stock['ÿßŸÑÿ•ÿ≥ŸÖ_ÿßŸÑŸÖÿÆÿ™ÿµÿ±'] || stock['Short Name'] || 'Unknown';
                const isInPortfolio = portfolio.some(p => p.stockName === stockName);
                
                // Create action buttons
                const watchlistButton = isInWatchlist 
                    ? `<button class="btn btn-small btn-remove" onclick="removeFromWatchlistByIndex(${index})" title="Remove from Watchlist">‚≠ê</button>`
                    : `<button class="btn btn-small btn-watchlist" onclick="addToWatchlistByIndex(${index})" title="Add to Watchlist">‚≠ê</button>`;
                
                const portfolioButton = `<button class="btn btn-small btn-wallet" onclick="addToPortfolioByIndex(${index})" title="Buy Stock">üí∞</button>`;
                
                const actionButtons = `<div style="display: flex; gap: 5px; justify-content: center;">${watchlistButton}${portfolioButton}</div>`;
                
                return `<tr>${row}<td>${actionButtons}</td></tr>`;
            }).join('');

            loading.style.display = 'none';
            table.style.display = 'table';
        }

        function displayWatchlist() {
            const table = document.getElementById('watchlistTable');
            const tableBody = document.getElementById('watchlistTableBody');
            const tableHeaders = document.getElementById('watchlistHeaders');
            const emptyWatchlist = document.getElementById('emptyWatchlist');

            if (filteredWatchlist.length === 0) {
                emptyWatchlist.style.display = 'block';
                table.style.display = 'none';
                return;
            }

            emptyWatchlist.style.display = 'none';

            // Create headers with action column (only visible columns)
            const allHeaders = Object.keys(filteredWatchlist[0]);
            const visibleHeaders = allHeaders.filter(header => columnVisibility[header] !== false);
            
            tableHeaders.innerHTML = visibleHeaders.map(header => {
                let sortClass = 'sortable';
                if (watchlistSortColumn === header) {
                    sortClass += ` sort-${watchlistSortDirection}`;
                }
                return `<th class="${sortClass}" onclick="sortWatchlist('${header}')">${header}</th>`;
            }).join('') + '<th>Action</th>';

            // Create rows (only visible columns)
            tableBody.innerHTML = filteredWatchlist.map((stock, index) => {
                const row = visibleHeaders.map(header => {
                    let value = stock[header] || '';
                    let className = '';
                    let displayValue = value;
                    
                    // Format numeric values for display
                    if (typeof value === 'number' && !isNaN(value)) {
                        if (header === '%ÿßŸÑÿ™ÿ∫ŸäŸäÿ±' || header === 'Changes %') {
                            displayValue = value.toFixed(2) + '%';
                        } else if (header === 'ÿ≠ÿ¨ŸÖ_ÿßŸÑÿ™ÿØÿßŸàŸÑ') {
                            displayValue = value.toLocaleString();
                        } else {
                            displayValue = smartFormatPrice(value);
                        }
                    }
                    
                    // Style based on column content
                    if (header === 'ÿ£ÿÆÿ±_ÿ≥ÿπÿ±' || header === 'Last Price') {
                        className = 'price-neutral';
                    } else if (header === '%ÿßŸÑÿ™ÿ∫ŸäŸäÿ±' || header === 'Changes %') {
                        const numValue = typeof value === 'number' ? value : parseFloat(value);
                        if (numValue > 0) className = 'price-positive';
                        else if (numValue < 0) className = 'price-negative';
                        else className = 'price-neutral';
                    }
                    
                    return `<td class="${className}">${displayValue}</td>`;
                }).join('');
                
                // Create action buttons similar to main stocks table
                const stockName = stock['ÿßŸÑÿ•ÿ≥ŸÖ_ÿßŸÑŸÖÿÆÿ™ÿµÿ±'] || stock['Short Name'] || 'Unknown';
                const isInPortfolio = portfolio.some(p => p.stockName === stockName);
                
                const removeButton = `<button class="btn btn-small btn-remove" onclick="removeFromWatchlistByWatchlistIndex(${index})" title="Remove from Watchlist">‚≠ê</button>`;
                const buyButton = `<button class="btn btn-small btn-wallet" onclick="addToPortfolioFromWatchlist(${index})" title="Buy Stock">üí∞</button>`;
                
                const actionButtons = `<div style="display: flex; gap: 5px; justify-content: center;">${removeButton}${buyButton}</div>`;
                
                return `<tr>${row}<td>${actionButtons}</td></tr>`;
            }).join('');

            table.style.display = 'table';
        }

        function filterStocks() {
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            currentSearchTerm = searchTerm;
            filteredStocks = allStocks.filter(stock => {
                return Object.values(stock).some(value => 
                    String(value).toLowerCase().includes(searchTerm)
                );
            });
            
            // Reapply sorting if there's an active sort
            if (currentSortColumn) {
                filteredStocks = sortData([...filteredStocks], currentSortColumn, currentSortDirection);
            }
            
            displayStocks();
        }

        function filterWatchlist() {
            const searchTerm = document.getElementById('watchlistSearchInput').value.toLowerCase();
            currentWatchlistSearchTerm = searchTerm;
            filteredWatchlist = watchlist.filter(stock => {
                return Object.values(stock).some(value => 
                    String(value).toLowerCase().includes(searchTerm)
                );
            });
            
            // Reapply sorting if there's an active sort
            if (watchlistSortColumn) {
                filteredWatchlist = sortData([...filteredWatchlist], watchlistSortColumn, watchlistSortDirection);
            }
            
            displayWatchlist();
        }

        function displayPortfolio() {
            const table = document.getElementById('walletTable');
            const tableBody = document.getElementById('walletTableBody');
            const emptyWallet = document.getElementById('emptyWallet');

            if (filteredPortfolio.length === 0) {
                emptyWallet.style.display = 'block';
                table.style.display = 'none';
                return;
            }

            emptyWallet.style.display = 'none';
            
            // Calculate portfolio values with current prices
            const portfolioWithValues = filteredPortfolio.map(portfolioItem => {
                const currentStock = allStocks.find(stock => 
                    stock['ÿßŸÑÿ•ÿ≥ŸÖ_ÿßŸÑŸÖÿÆÿ™ÿµÿ±'] === portfolioItem.stockName || 
                    stock['Short Name'] === portfolioItem.stockName
                );
                
                const currentPrice = currentStock ? 
                    (currentStock['ÿ£ÿÆÿ±_ÿ≥ÿπÿ±'] || currentStock['Last Price'] || portfolioItem.buyPrice) : 
                    portfolioItem.buyPrice;
                
                const investment = portfolioItem.shares * portfolioItem.buyPrice;
                console.log(`üîç Portfolio item ${portfolioItem.stockName}:`);
                console.log(`   - shares: ${portfolioItem.shares}`);
                console.log(`   - buyPrice: ${portfolioItem.buyPrice}`);
                console.log(`   - investment (shares √ó buyPrice): ${investment}`);
                console.log(`   - currentPrice: ${currentPrice}`);
                console.log(`   - Total Buy Price will show: ${smartFormatPrice(portfolioItem.shares * portfolioItem.buyPrice)}`);
                const currentValue = portfolioItem.shares * currentPrice;
                const pnl = currentValue - investment;
                const pnlPercent = investment > 0 ? (pnl / investment) * 100 : 0;
                
                return {
                    ...portfolioItem,
                    currentPrice,
                    investment,
                    currentValue,
                    pnl,
                    pnlPercent
                };
            });

            tableBody.innerHTML = portfolioWithValues.map((item, index) => {
                const pnlClass = item.pnl >= 0 ? 'positive' : 'negative';
                const pnlSign = item.pnl >= 0 ? '+' : '';
                
                // Calculate average price for this stock
                const averagePrice = calculateAveragePrice(item.stockName);
                
                return `
                    <tr>
                        <td>${item.stockName}</td>
                        <td>${item.shares}</td>
                        <td class="price-neutral">EGP ${smartFormatPrice(averagePrice)}</td>
                        <td>EGP ${smartFormatPrice(item.shares * item.buyPrice)}</td>
                        <td>EGP ${smartFormatPrice(item.currentPrice)}</td>
                        <td>EGP ${smartFormatPrice(item.currentValue)}</td>
                        <td class="${pnlClass}">${pnlSign}EGP ${smartFormatPrice(item.pnl)}</td>
                        <td class="${pnlClass}">${pnlSign}${item.pnlPercent.toFixed(2)}%</td>
                        <td>
                            <div style="display: flex; gap: 5px; justify-content: center;">
                                <button class="btn btn-small btn-watchlist" onclick="showSellStockModal('${item.stockName}', ${item.shares}, ${item.buyPrice})" title="Sell Stock">üí∏</button>
                            </div>
                        </td>
                    </tr>
                `;
            }).join('');

            table.style.display = 'table';
            updatePortfolioSummary();
        }

        function filterPortfolio() {
            const searchTerm = document.getElementById('walletSearchInput').value.toLowerCase();
            currentWalletSearchTerm = searchTerm;
            filteredPortfolio = portfolio.filter(item => {
                return item.stockName.toLowerCase().includes(searchTerm);
            });
            
            displayPortfolio();
        }

        // Calculate average price for a stock from portfolio data
        function calculateAveragePrice(stockName) {
            const stockItems = portfolio.filter(item => item.stockName === stockName);
            
            if (stockItems.length === 0) return 0;
            
            let totalShares = 0;
            let totalCost = 0;
            
            stockItems.forEach(item => {
                totalShares += item.shares;
                totalCost += item.shares * item.buyPrice;
            });
            
            return totalShares > 0 ? (totalCost / totalShares) : 0;
        }

        // Smart price formatting - removes trailing zeros while maintaining precision
        function smartFormatPrice(price) {
            if (typeof price !== 'number' || isNaN(price)) return '0';
            return parseFloat(price.toFixed(3)).toString();
        }

        function updatePortfolioSummary() {
            let totalInvestment = 0;
            let totalCurrentValue = 0;
            
            console.log('üîÑ Updating portfolio summary...');
            console.log('üìä Portfolio items:', portfolio.length);
            console.log('üìä Available stock data:', allStocks.length);
            
            portfolio.forEach(item => {
                const currentStock = allStocks.find(stock => 
                    stock['ÿßŸÑÿ•ÿ≥ŸÖ_ÿßŸÑŸÖÿÆÿ™ÿµÿ±'] === item.stockName || 
                    stock['Short Name'] === item.stockName
                );
                
                const currentPrice = currentStock ? 
                    (currentStock['ÿ£ÿÆÿ±_ÿ≥ÿπÿ±'] || currentStock['Last Price'] || item.buyPrice) : 
                    item.buyPrice;
                
                const itemInvestment = item.shares * item.buyPrice;
                const itemCurrentValue = item.shares * currentPrice;
                
                totalInvestment += itemInvestment;
                totalCurrentValue += itemCurrentValue;
                
                console.log(`üìà ${item.stockName}: ${item.shares} shares @ ${item.buyPrice} = ${smartFormatPrice(itemInvestment)} | Current: ${currentPrice} = ${smartFormatPrice(itemCurrentValue)}`);
            });
            
            const totalPnL = totalCurrentValue - totalInvestment;
            const totalPnLPercent = totalInvestment > 0 ? (totalPnL / totalInvestment) * 100 : 0;
            
            const pnlClass = totalPnL >= 0 ? 'positive' : 'negative';
            const pnlSign = totalPnL >= 0 ? '+' : '';
            
            console.log(`üí∞ Summary: Investment: ${smartFormatPrice(totalInvestment)}, Current: ${smartFormatPrice(totalCurrentValue)}, P&L: ${smartFormatPrice(totalPnL)} (${totalPnLPercent.toFixed(2)}%)`);
            
            document.getElementById('totalInvestment').textContent = `EGP ${smartFormatPrice(totalInvestment)}`;
            document.getElementById('currentValue').textContent = `EGP ${smartFormatPrice(totalCurrentValue)}`;
            document.getElementById('totalPnL').textContent = `${pnlSign}EGP ${smartFormatPrice(totalPnL)}`;
            document.getElementById('totalPnL').className = `stat-value ${pnlClass}`;
            document.getElementById('totalPnLPercent').textContent = `${pnlSign}${totalPnLPercent.toFixed(2)}%`;
            document.getElementById('totalPnLPercent').className = `stat-value ${pnlClass}`;
            
            // Also update all-time investment summary
            updateAllTimeInvestmentSummary();
        }

        function updateAllTimeInvestmentSummary() {
            let allTimeInvestment = 0;
            let allTimeSales = 0;
            
            console.log('üîÑ Updating all-time investment summary...');
            console.log('üìä Total transactions:', transactions.length);
            
            transactions.forEach(transaction => {
                if (transaction.type === 'BUY') {
                    allTimeInvestment += transaction.total;
                    console.log(`üí∞ Buy: ${transaction.stockName} - ${transaction.shares} shares @ ${transaction.price} = ${smartFormatPrice(transaction.total)}`);
                } else if (transaction.type === 'SELL') {
                    allTimeSales += transaction.total;
                    console.log(`üí∏ Sell: ${transaction.stockName} - ${transaction.shares} shares @ ${transaction.price} = ${smartFormatPrice(transaction.total)}`);
                }
            });
            
            // Calculate current portfolio value (this IS the net investment)
            let currentPortfolioValue = 0;
            portfolio.forEach(item => {
                const currentStock = allStocks.find(stock => 
                    stock['ÿßŸÑÿ•ÿ≥ŸÖ_ÿßŸÑŸÖÿÆÿ™ÿµÿ±'] === item.stockName || 
                    stock['Short Name'] === item.stockName
                );
                
                const currentPrice = currentStock ? 
                    (currentStock['ÿ£ÿÆÿ±_ÿ≥ÿπÿ±'] || currentStock['Last Price'] || item.buyPrice) : 
                    item.buyPrice;

                currentPortfolioValue += item.shares * currentPrice;
            });

            // Net Investment = Current value of remaining holdings
            const netInvestment = currentPortfolioValue;

            // Calculate all-time P&L: Current portfolio value + sales proceeds - total investment
            const allTimePnL = (currentPortfolioValue + allTimeSales) - allTimeInvestment;
            
            const pnlClass = allTimePnL >= 0 ? 'positive' : 'negative';
            const pnlSign = allTimePnL >= 0 ? '+' : '';
            
            console.log(`üìä All-Time Summary: Investment: ${smartFormatPrice(allTimeInvestment)}, Sales: ${smartFormatPrice(allTimeSales)}, Net: ${smartFormatPrice(netInvestment)}, P&L: ${smartFormatPrice(allTimePnL)}`);
            
            document.getElementById('allTimeInvestment').textContent = `EGP ${smartFormatPrice(allTimeInvestment)}`;
            document.getElementById('allTimeSales').textContent = `EGP ${smartFormatPrice(allTimeSales)}`;
            document.getElementById('netInvestment').textContent = `EGP ${smartFormatPrice(netInvestment)}`;
            document.getElementById('allTimePnL').textContent = `${pnlSign}EGP ${smartFormatPrice(allTimePnL)}`;
            document.getElementById('allTimePnL').className = `stat-value ${pnlClass}`;
        }

        function addToWatchlistByIndex(index) {
            try {
                const stock = filteredStocks[index];
                if (!stock) {
                    showStatus('Stock not found', 'error');
                    return;
                }
                
                // Check if already exists
                const exists = watchlist.some(w => JSON.stringify(w) === JSON.stringify(stock));
                if (!exists) {
                    watchlist.push(stock);
                    saveWatchlist();
                    displayStocks(); // Refresh to update button states
                    showStatus('Stock added to watchlist', 'success');
                } else {
                    showStatus('Stock already in watchlist', 'info');
                }
            } catch (error) {
                console.error('Error adding to watchlist:', error);
                showStatus('Error adding to watchlist', 'error');
            }
        }

        function removeFromWatchlistByIndex(index) {
            try {
                const stock = filteredStocks[index];
                if (!stock) {
                    showStatus('Stock not found', 'error');
                    return;
                }
                
                // Remove from main watchlist
                watchlist = watchlist.filter(w => JSON.stringify(w) !== JSON.stringify(stock));
                
                // Update filtered watchlist if it contains the removed stock
                filteredWatchlist = filteredWatchlist.filter(w => JSON.stringify(w) !== JSON.stringify(stock));
                
                // Reapply sorting if there's an active sort
                if (watchlistSortColumn) {
                    filteredWatchlist = sortData([...filteredWatchlist], watchlistSortColumn, watchlistSortDirection);
                }
                
                saveWatchlist();
                displayWatchlist();
                displayStocks(); // Refresh to update button states
                showStatus('Stock removed from watchlist', 'success');
            } catch (error) {
                console.error('Error removing from watchlist:', error);
                showStatus('Error removing from watchlist', 'error');
            }
        }

        function removeFromWatchlistByWatchlistIndex(index) {
            try {
                const stock = filteredWatchlist[index];
                if (!stock) {
                    showStatus('Stock not found', 'error');
                    return;
                }
                
                // Remove from main watchlist
                watchlist = watchlist.filter(w => JSON.stringify(w) !== JSON.stringify(stock));
                
                // Update filtered watchlist
                filteredWatchlist = filteredWatchlist.filter(w => JSON.stringify(w) !== JSON.stringify(stock));
                
                // Reapply sorting if there's an active sort
                if (watchlistSortColumn) {
                    filteredWatchlist = sortData([...filteredWatchlist], watchlistSortColumn, watchlistSortDirection);
                }
                
                saveWatchlist();
                displayWatchlist();
                displayStocks(); // Refresh to update button states
                showStatus('Stock removed from watchlist', 'success');
            } catch (error) {
                console.error('Error removing from watchlist:', error);
                showStatus('Error removing from watchlist', 'error');
            }
        }

        function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelector(`[onclick="switchTab('${tabName}')"]`).classList.add('active');

            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            document.getElementById(tabName).classList.add('active');

            // Handle special styling for exchange news tab
            const container = document.querySelector('.container');
            const mainContent = document.querySelector('.main-content');
            
            if (tabName === 'exchange-news') {
                container.classList.add('exchange-news-active');
                mainContent.classList.add('exchange-news-active');
            } else {
                container.classList.remove('exchange-news-active');
                mainContent.classList.remove('exchange-news-active');
            }

            // Refresh data when switching to tabs
            if (tabName === 'watchlist') {
                loadWatchlist();
            } else if (tabName === 'wallet') {
                loadPortfolio();
                updatePortfolioSummary(); // Ensure summary is up to date (this will also call updateAllTimeInvestmentSummary)
            } else if (tabName === 'exchange-news') {
                loadExchangeNews();
            }
        }

        // News Modal Functions
        function toggleNewsModal() {
            const modal = document.getElementById('newsModal');
            if (modal.style.display === 'none' || modal.style.display === '') {
                showNewsModal();
            } else {
                hideNewsModal();
            }
        }

        function showNewsModal() {
            const modal = document.getElementById('newsModal');
            modal.style.display = 'flex';
            loadNews();
            hideNewsNotificationDot(); // Hide notification dot when user opens news
            
            // Close modal when clicking outside
            modal.onclick = function(event) {
                if (event.target === modal) {
                    hideNewsModal();
                }
            };
        }

        function hideNewsModal() {
            document.getElementById('newsModal').style.display = 'none';
        }

        // Close news modal with ESC key
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                const newsModal = document.getElementById('newsModal');
                if (newsModal && newsModal.style.display === 'flex') {
                    hideNewsModal();
                }
            }
        });

        function showAddStockModal() {
            populateStockSelect();
            document.getElementById('addStockModal').style.display = 'flex';
            // Set default date to today
            document.getElementById('buyDateInput').value = new Date().toISOString().split('T')[0];
        }

        function hideAddStockModal() {
            document.getElementById('addStockModal').style.display = 'none';
            // Clear form
            document.getElementById('stockSelect').value = '';
            document.getElementById('sharesInput').value = '';
            document.getElementById('buyPriceInput').value = '';
            document.getElementById('buyDateInput').value = '';
            document.getElementById('stockInfo').style.display = 'none';
        }

        function populateStockSelect() {
            const select = document.getElementById('stockSelect');
            select.innerHTML = '<option value="">Choose a stock...</option>';
            
            allStocks.forEach(stock => {
                const stockName = stock['ÿßŸÑÿ•ÿ≥ŸÖ_ÿßŸÑŸÖÿÆÿ™ÿµÿ±'] || stock['Short Name'] || 'Unknown';
                const option = document.createElement('option');
                option.value = stockName;
                option.textContent = stockName;
                select.appendChild(option);
            });
        }

        function updateStockInfo() {
            const selectedStock = document.getElementById('stockSelect').value;
            const stockInfo = document.getElementById('stockInfo');
            
            if (!selectedStock) {
                stockInfo.style.display = 'none';
                return;
            }
            
            const stock = allStocks.find(s => 
                (s['ÿßŸÑÿ•ÿ≥ŸÖ_ÿßŸÑŸÖÿÆÿ™ÿµÿ±'] || s['Short Name']) === selectedStock
            );
            
            if (stock) {
                const currentPrice = stock['ÿ£ÿÆÿ±_ÿ≥ÿπÿ±'] || stock['Last Price'] || 0;
                const change = stock['%ÿßŸÑÿ™ÿ∫ŸäŸäÿ±'] || stock['Changes %'] || 0;
                
                document.getElementById('currentPriceDisplay').textContent = `EGP ${smartFormatPrice(currentPrice)}`;
                
                const changeElement = document.getElementById('changeDisplay');
                const changeClass = change >= 0 ? 'positive' : 'negative';
                const changeSign = change >= 0 ? '+' : '';
                changeElement.textContent = `${changeSign}${change.toFixed(2)}%`;
                changeElement.className = `info-value ${changeClass}`;
                
                stockInfo.style.display = 'block';
            } else {
                stockInfo.style.display = 'none';
            }
        }

        // Removed old addStockToPortfolio function - replaced by buy modal system

        function removeMatchingBuyTransactions(stockName, shares, buyPrice) {
            try {
                console.log(`üîç Looking for matching buy transactions for ${stockName}: ${shares} shares @ ${buyPrice}`);
                console.log(`üìä Total transactions before filtering: ${transactions.length}`);
                
                // Get all buy transactions for this stock
                const buyTransactionsForStock = transactions.filter(transaction => 
                    transaction.type === 'BUY' && transaction.stockName === stockName
                );
                
                console.log(`üìä Found ${buyTransactionsForStock.length} buy transactions for ${stockName}`);
                
                if (buyTransactionsForStock.length === 0) {
                    console.log(`‚ö†Ô∏è No buy transactions found for ${stockName}`);
                    return;
                }
                
                // Find exact matching transactions (same shares and price)
                const exactMatches = buyTransactionsForStock.filter(transaction => {
                    const sameShares = transaction.shares === shares;
                    const samePrice = Math.abs(transaction.price - buyPrice) < 0.01;
                    return sameShares && samePrice;
                });
                
                console.log(`üìä Found ${exactMatches.length} exact matching transactions`);
                
                if (exactMatches.length > 0) {
                    // Remove only the exact matching transactions
                    const originalLength = transactions.length;
                    transactions = transactions.filter(transaction => {
                        const isBuy = transaction.type === 'BUY';
                        const sameStock = transaction.stockName === stockName;
                        const sameShares = transaction.shares === shares;
                        const samePrice = Math.abs(transaction.price - buyPrice) < 0.01;
                        
                        // Only remove if it's an exact match
                        return !(isBuy && sameStock && sameShares && samePrice);
                    });
                    
                    console.log(`üóëÔ∏è Removed ${originalLength - transactions.length} exact matching buy transactions`);
                    console.log(`üìä Remaining transactions: ${transactions.length}`);
                } else {
                    console.log(`‚ö†Ô∏è No exact matching transactions found to remove`);
                    console.log(`üìä Available buy transactions for ${stockName}:`, buyTransactionsForStock.map(t => ({
                        shares: t.shares,
                        price: t.price,
                        total: t.total
                    })));
                }
            } catch (error) {
                console.error('Error removing matching buy transactions:', error);
            }
        }

        function removeFromPortfolio(index) {
            try {
                const item = filteredPortfolio[index];
                if (!item) {
                    showStatus('Portfolio item not found', 'error');
                    return;
                }
                
                console.log(`üóëÔ∏è Removing portfolio item:`, {
                    stockName: item.stockName,
                    shares: item.shares,
                    buyPrice: item.buyPrice
                });
                
                // Remove matching buy transactions from history
                removeMatchingBuyTransactions(item.stockName, item.shares, item.buyPrice);
                
                // Remove from main portfolio
                portfolio = portfolio.filter(p => p.stockName !== item.stockName);
                
                // Update filtered portfolio
                filteredPortfolio = filteredPortfolio.filter(p => p.stockName !== item.stockName);
                
                savePortfolio();
                saveTransactions(); // Save updated transactions
                displayPortfolio();
                displayTransactionHistory(); // Refresh transaction history
                
                // Request fresh stock data and then update summary
                ipcRenderer.invoke('get-stock-data').then(data => {
                    if (data && data.length > 0) {
                        allStocks = data;
                        updatePortfolioSummary(); // Update summary with fresh data
                    } else {
                        updatePortfolioSummary(); // Update summary with existing data
                    }
                }).catch(error => {
                    console.error('Error getting fresh stock data:', error);
                    updatePortfolioSummary(); // Update summary with existing data
                });
                
                showStatus('Stock removed from portfolio', 'success');
            } catch (error) {
                console.error('Error removing from portfolio:', error);
                showStatus('Error removing from portfolio', 'error');
            }
        }

        function addToPortfolioByIndex(index) {
            try {
                const stock = filteredStocks[index];
                if (!stock) {
                    showStatus('Stock not found', 'error');
                    return;
                }
                
                const stockName = stock['ÿßŸÑÿ•ÿ≥ŸÖ_ÿßŸÑŸÖÿÆÿ™ÿµÿ±'] || stock['Short Name'] || 'Unknown';
                const currentPrice = stock['ÿ£ÿÆÿ±_ÿ≥ÿπÿ±'] || stock['Last Price'] || 0;
                
                // Always open buy modal - allows adding more shares to existing portfolio
                showBuyStockModal(stockName, currentPrice, stock);
            } catch (error) {
                console.error('Error adding to portfolio:', error);
                showStatus('Error adding to portfolio', 'error');
            }
        }

        function addToPortfolioFromWatchlist(index) {
            try {
                const stock = filteredWatchlist[index];
                if (!stock) {
                    showStatus('Stock not found in watchlist', 'error');
                    return;
                }
                
                const stockName = stock['ÿßŸÑÿ•ÿ≥ŸÖ_ÿßŸÑŸÖÿÆÿ™ÿµÿ±'] || stock['Short Name'] || 'Unknown';
                const currentPrice = stock['ÿ£ÿÆÿ±_ÿ≥ÿπÿ±'] || stock['Last Price'] || 0;
                
                // Always open buy modal - allows adding more shares to existing portfolio
                showBuyStockModal(stockName, currentPrice, stock);
            } catch (error) {
                console.error('Error adding to portfolio from watchlist:', error);
                showStatus('Error adding to portfolio', 'error');
            }
        }

        function removeFromPortfolioByStockName(stockName) {
            try {
                console.log(`üóëÔ∏è Removing portfolio item by stock name: ${stockName}`);
                
                // Find the portfolio item to get its details
                const portfolioItem = portfolio.find(p => p.stockName === stockName);
                
                if (portfolioItem) {
                    console.log(`üóëÔ∏è Found portfolio item:`, {
                        stockName: portfolioItem.stockName,
                        shares: portfolioItem.shares,
                        buyPrice: portfolioItem.buyPrice
                    });
                    
                    // Remove matching buy transactions from history
                    removeMatchingBuyTransactions(portfolioItem.stockName, portfolioItem.shares, portfolioItem.buyPrice);
                } else {
                    console.log(`‚ö†Ô∏è Portfolio item not found for stock: ${stockName}`);
                }
                
                // Remove from main portfolio
                portfolio = portfolio.filter(p => p.stockName !== stockName);
                
                // Update filtered portfolio
                filteredPortfolio = filteredPortfolio.filter(p => p.stockName !== stockName);
                
                savePortfolio();
                saveTransactions(); // Save updated transactions
                displayPortfolio();
                displayTransactionHistory(); // Refresh transaction history
                
                // Request fresh stock data and then update summary
                ipcRenderer.invoke('get-stock-data').then(data => {
                    if (data && data.length > 0) {
                        allStocks = data;
                        updatePortfolioSummary(); // Update summary with fresh data
                    } else {
                        updatePortfolioSummary(); // Update summary with existing data
                    }
                }).catch(error => {
                    console.error('Error getting fresh stock data:', error);
                    updatePortfolioSummary(); // Update summary with existing data
                });
                
                displayStocks(); // Refresh to update button states
                showStatus('Stock removed from portfolio', 'success');
            } catch (error) {
                console.error('Error removing from portfolio:', error);
                showStatus('Error removing from portfolio', 'error');
            }
        }

        // Buy Stock Modal Functions
        function showBuyModalValidation(message) {
            const validationDiv = document.getElementById('buyModalValidation');
            validationDiv.textContent = message;
            validationDiv.style.display = 'block';
            
            // Auto-hide after 5 seconds
            setTimeout(() => {
                validationDiv.style.display = 'none';
            }, 5000);
        }

        function hideBuyModalValidation() {
            document.getElementById('buyModalValidation').style.display = 'none';
        }

        function showBuyStockModal(stockName, currentPrice, stock) {
            // Clear any previous validation messages
            hideBuyModalValidation();
            
            document.getElementById('buyStockName').value = stockName;
            document.getElementById('buyModalPriceInput').value = ''; // Force user to enter their desired buy price
            document.getElementById('buyModalDateInput').value = new Date().toISOString().split('T')[0];
            document.getElementById('buySharesInput').value = '1';
            
            // Show current stock info
            if (stock) {
                const change = stock['%ÿßŸÑÿ™ÿ∫ŸäŸäÿ±'] || stock['Changes %'] || 0;
                document.getElementById('buyCurrentPriceDisplay').textContent = `EGP ${smartFormatPrice(currentPrice)}`;
                
                const changeElement = document.getElementById('buyChangeDisplay');
                const changeClass = change >= 0 ? 'positive' : 'negative';
                const changeSign = change >= 0 ? '+' : '';
                changeElement.textContent = `${changeSign}${change.toFixed(2)}%`;
                changeElement.className = `info-value ${changeClass}`;
                
                document.getElementById('buyStockInfo').style.display = 'block';
            }
            
            document.getElementById('buyStockModal').style.display = 'flex';
        }

        function hideBuyStockModal() {
            document.getElementById('buyStockModal').style.display = 'none';
            // Clear validation messages
            hideBuyModalValidation();
            // Clear form
            document.getElementById('buyStockName').value = '';
            document.getElementById('buySharesInput').value = '';
            document.getElementById('buyModalPriceInput').value = '';
            document.getElementById('buyModalDateInput').value = '';
            document.getElementById('buyStockInfo').style.display = 'none';
        }

        function confirmBuyStock() {
            console.log('üöÄ confirmBuyStock() function started');
            console.log('üìç Function called at:', new Date().toISOString());
            
            const stockName = document.getElementById('buyStockName').value;
            const shares = parseInt(document.getElementById('buySharesInput').value);
            const buyPrice = parseFloat(document.getElementById('buyModalPriceInput').value);
            const buyDate = document.getElementById('buyModalDateInput').value;
            
            console.log('üìä Buy transaction inputs:', {
                stockName,
                shares,
                buyPrice,
                buyDate,
                rawPriceInput: document.getElementById('buyModalPriceInput').value,
                rawSharesInput: document.getElementById('buySharesInput').value,
                rawDateInput: document.getElementById('buyModalDateInput').value
            });
            
            // Validation
            console.log('üîç Starting validation checks...');
            
            if (!stockName) {
                console.log('‚ùå Validation failed: Stock name is empty');
                showBuyModalValidation('Stock name is required');
                return;
            }
            console.log('‚úÖ Stock name validation passed:', stockName);
            
            if (!shares || shares <= 0) {
                console.log('‚ùå Validation failed: Invalid shares:', shares);
                showBuyModalValidation('Please enter a valid number of shares');
                return;
            }
            console.log('‚úÖ Shares validation passed:', shares);
            
            if (!buyPrice || isNaN(buyPrice) || buyPrice <= 0) {
                console.error(`‚ùå Buy price validation failed:`, {
                    inputValue: document.getElementById('buyModalPriceInput').value,
                    parsedValue: buyPrice,
                    isNaN: isNaN(buyPrice),
                    isLessOrEqual0: buyPrice <= 0
                });
                showBuyModalValidation('Please enter a valid buy price');
                console.log('‚ùå Buy validation failed - modal will not close');
                return;
            }
            console.log('‚úÖ Buy price validation passed:', buyPrice);
            
            if (!buyDate) {
                console.log('‚ùå Validation failed: Buy date is empty');
                showBuyModalValidation('Please select a buy date');
                return;
            }
            console.log('‚úÖ Buy date validation passed:', buyDate);
            
            console.log('‚úÖ All buy validations passed, proceeding with transaction...');
            
            // Check if stock already exists in portfolio
            console.log('üîç Checking if stock exists in portfolio...');
            const existingIndex = portfolio.findIndex(item => item.stockName === stockName);
            console.log('üìä Portfolio check result:', { existingIndex, portfolioLength: portfolio.length });
            
            if (existingIndex >= 0) {
                console.log('üìà Stock exists in portfolio, updating existing entry...');
                // Update existing entry (average price calculation)
                const existingItem = portfolio[existingIndex];
                const totalShares = existingItem.shares + shares;
                const totalInvestment = (existingItem.shares * existingItem.buyPrice) + (shares * buyPrice);
                const averagePrice = totalInvestment / totalShares;
                
                console.log(`üí∞ Updating existing stock: ${stockName}`);
                console.log(`üìä Previous: ${existingItem.shares} shares @ ${existingItem.buyPrice}`);
                console.log(`üìä Adding: ${shares} shares @ ${buyPrice}`);
                console.log(`üìä New total: ${totalShares} shares @ ${smartFormatPrice(averagePrice)} average`);
                
                portfolio[existingIndex].shares = totalShares;
                portfolio[existingIndex].buyPrice = averagePrice; // Average price for calculations
                portfolio[existingIndex].lastBuyPrice = buyPrice; // Most recent purchase price for display
                console.log(`üíæ Updated portfolio item:`, portfolio[existingIndex]);
                // Keep the original buy date, don't overwrite it
            } else {
                console.log('‚ú® Stock is new, adding to portfolio...');
                // Add new entry
                console.log(`üí∞ Adding new stock: ${stockName}`);
                console.log(`üìä Shares: ${shares} @ ${buyPrice} on ${buyDate}`);
                
                const newPortfolioItem = {
                    stockName,
                    shares,
                    buyPrice,
                    buyDate,
                    lastBuyPrice: buyPrice // For new stocks, last buy price = buy price
                };
                console.log(`üíæ Storing new portfolio item:`, newPortfolioItem);
                portfolio.push(newPortfolioItem);
            }
            
            // Add transaction record
            console.log('üíæ Adding transaction record...');
            transactions.push({
                id: Date.now(),
                date: buyDate,
                stockName,
                type: 'BUY',
                shares,
                price: buyPrice,
                total: shares * buyPrice
            });
            console.log('‚úÖ Transaction record added');
            
            console.log('üíæ Saving portfolio and transactions...');
            savePortfolio();
            saveTransactions();
            console.log('‚úÖ Data saved successfully');
            
            console.log('üîÑ Updating displays...');
            displayPortfolio();
            displayTransactionHistory();
            console.log('‚úÖ Displays updated');
            
            // Request fresh stock data and then update summary
            ipcRenderer.invoke('get-stock-data').then(data => {
                if (data && data.length > 0) {
                    allStocks = data;
                    updatePortfolioSummary(); // Update summary with fresh data
                } else {
                    updatePortfolioSummary(); // Update summary with existing data
                }
            }).catch(error => {
                console.error('Error getting fresh stock data:', error);
                updatePortfolioSummary(); // Update summary with existing data
            });
            
            displayStocks(); // Refresh to update button states
            
            console.log('‚úÖ Buy transaction completed successfully, closing modal...');
            
            // Close modal immediately and show success message in main interface
            try {
                console.log('üîÑ Attempting to close buy modal...');
                hideBuyStockModal();
                console.log('‚úÖ Buy modal close function called successfully');
                showStatus(`‚úÖ Stock bought: ${shares} shares of ${stockName} at EGP ${smartFormatPrice(buyPrice)}`, 'success');
            } catch (error) {
                console.error('‚ùå Error closing buy modal:', error);
            }
        }

        // Test function to verify confirmBuyStock exists
        function testConfirmBuyStockExists() {
            console.log('üß™ Testing if confirmBuyStock function exists...');
            if (typeof confirmBuyStock === 'function') {
                console.log('‚úÖ confirmBuyStock function exists and is callable');
            } else {
                console.error('‚ùå confirmBuyStock function does not exist!');
            }
        }

        // Test functions for debugging modal closing
        function testCloseBuyModal() {
            console.log('üîß Test: Attempting to close buy modal...');
            try {
                hideBuyStockModal();
                console.log('‚úÖ Test: Buy modal closed successfully');
            } catch (error) {
                console.error('‚ùå Test: Error closing buy modal:', error);
            }
        }

        function testCloseSellModal() {
            console.log('üîß Test: Attempting to close sell modal...');
            try {
                hideSellStockModal();
                console.log('‚úÖ Test: Sell modal closed successfully');
            } catch (error) {
                console.error('‚ùå Test: Error closing sell modal:', error);
            }
        }

        // Sell Stock Modal Functions
        function showSellStockModal(stockName, currentShares, avgBuyPrice) {
            // Clear any previous validation messages
            hideSellModalValidation();
            
            document.getElementById('sellStockName').value = stockName;
            document.getElementById('sellMaxShares').textContent = currentShares;
            document.getElementById('sellSharesInput').max = currentShares;
            document.getElementById('sellSharesInput').value = '1';
            document.getElementById('sellDateInput').value = new Date().toISOString().split('T')[0];
            
            // Get current stock info
            const stock = allStocks.find(s => 
                (s['ÿßŸÑÿ•ÿ≥ŸÖ_ÿßŸÑŸÖÿÆÿ™ÿµÿ±'] || s['Short Name']) === stockName
            );
            
            if (stock) {
                const currentPrice = stock['ÿ£ÿÆÿ±_ÿ≥ÿπÿ±'] || stock['Last Price'] || 0;
                const change = stock['%ÿßŸÑÿ™ÿ∫ŸäŸäÿ±'] || stock['Changes %'] || 0;
                
                document.getElementById('sellPriceInput').value = smartFormatPrice(currentPrice);
                document.getElementById('sellCurrentPriceDisplay').textContent = `EGP ${smartFormatPrice(currentPrice)}`;
                document.getElementById('sellYourSharesDisplay').textContent = `${currentShares} shares`;
                document.getElementById('sellAvgPriceDisplay').textContent = `EGP ${smartFormatPrice(avgBuyPrice)}`;
                
                const changeElement = document.getElementById('sellChangeDisplay');
                const changeClass = change >= 0 ? 'positive' : 'negative';
                const changeSign = change >= 0 ? '+' : '';
                changeElement.textContent = `${changeSign}${change.toFixed(2)}%`;
                changeElement.className = `info-value ${changeClass}`;
                
                document.getElementById('sellStockInfo').style.display = 'block';
            }
            
            document.getElementById('sellStockModal').style.display = 'flex';
        }

        function showSellModalValidation(message) {
            const validationDiv = document.getElementById('sellModalValidation');
            validationDiv.textContent = message;
            validationDiv.style.display = 'block';
            
            // Auto-hide after 5 seconds
            setTimeout(() => {
                validationDiv.style.display = 'none';
            }, 5000);
        }

        function hideSellModalValidation() {
            document.getElementById('sellModalValidation').style.display = 'none';
        }

        function hideSellStockModal() {
            document.getElementById('sellStockModal').style.display = 'none';
            // Clear validation messages
            hideSellModalValidation();
            // Clear form
            document.getElementById('sellStockName').value = '';
            document.getElementById('sellSharesInput').value = '';
            document.getElementById('sellPriceInput').value = '';
            document.getElementById('sellDateInput').value = '';
            document.getElementById('sellStockInfo').style.display = 'none';
        }

        function confirmSellStock() {
            const stockName = document.getElementById('sellStockName').value;
            const sharesToSell = parseInt(document.getElementById('sellSharesInput').value);
            const sellPrice = parseFloat(document.getElementById('sellPriceInput').value);
            const sellDate = document.getElementById('sellDateInput').value;
            const maxShares = parseInt(document.getElementById('sellMaxShares').textContent);
            
            // Validation
            if (!stockName) {
                showSellModalValidation('Stock name is required');
                return;
            }
            
            if (!sharesToSell || sharesToSell <= 0) {
                showSellModalValidation('Please enter a valid number of shares to sell');
                return;
            }
            
            if (sharesToSell > maxShares) {
                showSellModalValidation(`Cannot sell more than ${maxShares} shares`);
                return;
            }
            
            if (!sellPrice || sellPrice <= 0) {
                showSellModalValidation('Please enter a valid sell price');
                return;
            }
            
            if (!sellDate) {
                showSellModalValidation('Please select a sell date');
                return;
            }
            
            console.log('‚úÖ All sell validations passed, proceeding with transaction...');
            
            // Find portfolio item
            const portfolioIndex = portfolio.findIndex(item => item.stockName === stockName);
            if (portfolioIndex === -1) {
                showStatus('Stock not found in portfolio', 'error');
                return;
            }
            
            const portfolioItem = portfolio[portfolioIndex];
            
            // Update portfolio
            console.log(`üí∏ Selling ${sharesToSell} shares of ${stockName}`);
            console.log(`üìä Current portfolio shares: ${portfolioItem.shares}`);
            console.log(`üìä Portfolio before update:`, portfolio);
            console.log(`üìä Filtered portfolio before update:`, filteredPortfolio);
            
            if (sharesToSell === portfolioItem.shares) {
                // Sell all shares - remove from portfolio
                console.log(`üóëÔ∏è Removing stock completely from portfolio`);
                portfolio.splice(portfolioIndex, 1);
            } else {
                // Sell partial shares - update remaining shares
                const newShares = portfolioItem.shares - sharesToSell;
                console.log(`üìâ Updating shares: ${portfolioItem.shares} - ${sharesToSell} = ${newShares}`);
                
                portfolio[portfolioIndex].shares = newShares;
            }
            
            console.log(`üìä Portfolio after update:`, portfolio);
            console.log(`üìä Filtered portfolio after update:`, filteredPortfolio);
            
            // Add transaction record
            transactions.push({
                id: Date.now(),
                date: sellDate,
                stockName,
                type: 'SELL',
                shares: sharesToSell,
                price: sellPrice,
                total: sharesToSell * sellPrice
            });
            
            savePortfolio();
            saveTransactions();
            
            // Update filtered portfolio and display
            filterPortfolio(); // This will update filteredPortfolio and call displayPortfolio()
            displayTransactionHistory();
            
            // Request fresh stock data and then update summary
            ipcRenderer.invoke('get-stock-data').then(data => {
                if (data && data.length > 0) {
                    allStocks = data;
                    updatePortfolioSummary(); // Update summary with fresh data
                } else {
                    updatePortfolioSummary(); // Update summary with existing data
                }
            }).catch(error => {
                console.error('Error getting fresh stock data:', error);
                updatePortfolioSummary(); // Update summary with existing data
            });
            
            displayStocks(); // Refresh to update button states
            
            console.log('‚úÖ Sell transaction completed successfully, closing modal...');
            
            // Close modal immediately and show success message in main interface
            try {
                console.log('üîÑ Attempting to close sell modal...');
                hideSellStockModal();
                console.log('‚úÖ Sell modal close function called successfully');
                showStatus(`‚úÖ Stock sold: ${sharesToSell} shares of ${stockName} at EGP ${smartFormatPrice(sellPrice)}`, 'success');
            } catch (error) {
                console.error('‚ùå Error closing sell modal:', error);
            }
        }

        // Transaction History Display
        function displayTransactionHistory() {
            const table = document.getElementById('transactionTable');
            const tableBody = document.getElementById('transactionTableBody');
            const emptyTransactions = document.getElementById('emptyTransactions');

            // Check if elements exist (they might not exist after UI changes)
            if (!table || !tableBody || !emptyTransactions) {
                console.log('üìä Transaction history elements not found, skipping display update');
                return;
            }

            if (transactions.length === 0) {
                emptyTransactions.style.display = 'block';
                table.style.display = 'none';
                return;
            }

            emptyTransactions.style.display = 'none';
            
            // Sort transactions by date (newest first)
            const sortedTransactions = [...transactions].sort((a, b) => new Date(b.date) - new Date(a.date));
            
            tableBody.innerHTML = sortedTransactions.map((transaction, index) => {
                const typeClass = transaction.type === 'BUY' ? 'positive' : 'negative';
                const typeIcon = transaction.type === 'BUY' ? 'üí∞' : 'üí∏';
                
                return `
                    <tr>
                        <td>${transaction.date}</td>
                        <td>${transaction.stockName}</td>
                        <td class="${typeClass}">${typeIcon} ${transaction.type}</td>
                        <td>${transaction.shares}</td>
                        <td>EGP ${smartFormatPrice(transaction.price)}</td>
                        <td>EGP ${smartFormatPrice(transaction.total)}</td>
                    </tr>
                `;
            }).join('');

            table.style.display = 'table';
            
            // Update all-time investment summary when transaction history is displayed
            updateAllTimeInvestmentSummary();
        }

        function clearTransactionHistory() {
            showClearTransactionConfirmModal();
        }

        // Transaction History Modal Functions
        function showTransactionHistoryModal() {
            displayModalTransactionHistory();
            document.getElementById('transactionHistoryModal').style.display = 'flex';
        }

        function hideTransactionHistoryModal() {
            document.getElementById('transactionHistoryModal').style.display = 'none';
        }

        function showTransactionModalMessage(message) {
            const validationDiv = document.getElementById('transactionModalValidation');
            validationDiv.textContent = message;
            validationDiv.style.display = 'block';
            
            // Auto-hide after 3 seconds
            setTimeout(() => {
                validationDiv.style.display = 'none';
            }, 3000);
        }

        function clearTransactionHistoryModal() {
            showClearTransactionConfirmModal();
        }

        // Clear Transaction Confirmation Modal Functions
        function showClearTransactionConfirmModal() {
            document.getElementById('clearTransactionConfirmModal').style.display = 'flex';
        }

        function hideClearTransactionConfirmModal() {
            document.getElementById('clearTransactionConfirmModal').style.display = 'none';
        }

        function confirmClearTransactionHistory() {
            // Hide the confirmation modal
            hideClearTransactionConfirmModal();
            
            // Clear the transactions
            transactions = [];
            saveTransactions();
            displayModalTransactionHistory();
            displayTransactionHistory(); // Also update the original display if it exists
            updateAllTimeInvestmentSummary();
            showTransactionModalMessage('‚úÖ Transaction history cleared successfully');
        }

        function displayModalTransactionHistory() {
            const table = document.getElementById('modalTransactionTable');
            const tableBody = document.getElementById('modalTransactionTableBody');
            const emptyTransactions = document.getElementById('modalEmptyTransactions');
            
            if (transactions.length === 0) {
                emptyTransactions.style.display = 'block';
                table.style.display = 'none';
                return;
            }
            
            emptyTransactions.style.display = 'none';
            
            // Sort transactions by date (newest first)
            const sortedTransactions = transactions.sort((a, b) => new Date(b.date) - new Date(a.date));
            
            tableBody.innerHTML = sortedTransactions.map(transaction => {
                const typeClass = transaction.type === 'BUY' ? 'positive' : 'negative';
                const typeIcon = transaction.type === 'BUY' ? 'üí∞' : 'üí∏';
                
                return `
                    <tr>
                        <td>${new Date(transaction.date).toLocaleDateString()}</td>
                        <td>${transaction.stockName}</td>
                        <td class="${typeClass}">${typeIcon} ${transaction.type}</td>
                        <td>${transaction.shares}</td>
                        <td>EGP ${smartFormatPrice(transaction.price)}</td>
                        <td>EGP ${smartFormatPrice(transaction.total)}</td>
                    </tr>
                `;
            }).join('');
            
            table.style.display = 'table';
        }



        async function startupDataLoad() {
            try {
                console.log(`üöÄ Startup data load attempt ${startupRetryCount + 1} (will retry until success)`);
                showUpdating();
                
                const response = await ipcRenderer.invoke('refresh-queries-and-data');
                
                // Check if refresh was successful or skipped
                if (!response.success) {
                    console.log('‚ö†Ô∏è Startup data load - no success response, waiting for stock-data-updated event...');
                    // Don't hide loading spinner yet - wait for event-based data
                    // The stock-data-updated event will handle the retry logic
                    return;
                }
                
                // Check if we have mock data (2 records) at startup
                if (response.data && response.data.length === 2) {
                    startupRetryCount++;
                    console.log(`‚ö†Ô∏è Mock data detected at startup (2 records) - attempt ${startupRetryCount}`);
                    console.log(`üîÑ Retrying in 3 seconds to get real data... (will keep trying until success)`);
                    
                    if (startupRetryTimer) clearTimeout(startupRetryTimer);
                    startupRetryTimer = setTimeout(() => {
                        startupDataLoad(); // Retry indefinitely
                    }, 3000);
                    return;
                }
                
                // Success - we have real data
                console.log(`‚úÖ Startup data load successful with ${response.data.length} records`);
                isStartupPhase = false; // End startup phase
                startupRetryCount = 0; // Reset retry count for future use
                if (startupRetryTimer) clearTimeout(startupRetryTimer);
                
                allStocks = response.data;
                
                // Update watchlist with fresh data
                updateWatchlistWithFreshData();
                
                // Preserve current search filter
                if (currentSearchTerm) {
                    filteredStocks = allStocks.filter(stock => {
                        return Object.values(stock).some(value => 
                            String(value).toLowerCase().includes(currentSearchTerm.toLowerCase())
                        );
                    });
                } else {
                    filteredStocks = [...allStocks];
                }
                
                // Reapply sorting if there's an active sort
                if (currentSortColumn) {
                    filteredStocks = sortData([...filteredStocks], currentSortColumn, currentSortDirection);
                }
                
                displayStocks();
                displayWatchlist();
                updateLastUpdated();
                updateRecordCounter();
                
            } catch (error) {
                console.error('Error in startup data load:', error);
                startupRetryCount++;
                
                console.log(`üîÑ Startup error - retrying in 5 seconds... (attempt ${startupRetryCount}, will keep trying)`);
                if (startupRetryTimer) clearTimeout(startupRetryTimer);
                startupRetryTimer = setTimeout(() => {
                    startupDataLoad(); // Retry indefinitely on error
                }, 5000);
            }
        }

        async function refreshQueriesAndData(isManualRefresh = false) {
            try {
                // Track manual refresh retry attempts
                if (isManualRefresh) {
                    if (!isManualRefreshRetrying) {
                        manualRefreshRetryCount = 0; // Reset count for new manual refresh
                        isManualRefreshRetrying = true;
                    }
                    manualRefreshRetryCount++;
                    console.log(`üîÑ Manual refresh attempt ${manualRefreshRetryCount} ${isManualRefreshRetrying && manualRefreshRetryCount > 1 ? '(retrying for real data)' : ''}`);
                }
                
                showUpdating();
                
                // Check market status before refreshing (only for automatic updates)
                if (!isManualRefresh && currentMarketStatus && currentMarketStatus.status === 'closed') {
                    console.log('üî¥ Market is closed - skipping auto update');
                    // Hide loading spinner when market is closed
                    const loadingSpinner = document.getElementById('loadingSpinner');
                    if (loadingSpinner) {
                        loadingSpinner.style.display = 'none';
                    }
                    return;
                }
                
                // Log manual refresh override
                if (isManualRefresh && currentMarketStatus && currentMarketStatus.status === 'closed') {
                    console.log('üîÑ Manual refresh - overriding market closed status');
                }
                
                const response = await ipcRenderer.invoke('refresh-queries-and-data');
                
                // Check if refresh was successful or skipped
                if (!response.success) {
                    // Hide loading spinner when refresh is skipped (no status message)
                    const loadingSpinner = document.getElementById('loadingSpinner');
                    if (loadingSpinner) {
                        loadingSpinner.style.display = 'none';
                    }
                    return;
                }
                
                // Check if we have mock data (2 records)
                if (response.data && response.data.length === 2) {
                    console.log('‚ö†Ô∏è Mock data detected (2 records)');
                    
                    // If this is a manual refresh, retry indefinitely
                    if (isManualRefresh) {
                        console.log(`üîÑ Manual refresh - mock data retry ${manualRefreshRetryCount} (will keep trying until real data)`);
                        console.log('üîÑ Retrying in 3 seconds to get real data...');
                        
                        if (manualRefreshRetryTimer) clearTimeout(manualRefreshRetryTimer);
                        manualRefreshRetryTimer = setTimeout(() => {
                            refreshQueriesAndData(true); // Retry manual refresh
                        }, 3000);
                        return;
                    } else {
                        // Auto refresh - just keep existing data
                        console.log('üìä Auto refresh - keeping existing scraped data');
                        const loadingSpinner = document.getElementById('loadingSpinner');
                        if (loadingSpinner) {
                            loadingSpinner.style.display = 'none';
                        }
                        updateRecordCounter();
                        return;
                    }
                }
                
                // Success - we have real data
                if (isManualRefresh && isManualRefreshRetrying) {
                    console.log(`‚úÖ Manual refresh successful with ${response.data.length} records after ${manualRefreshRetryCount} attempts`);
                    isManualRefreshRetrying = false;
                    manualRefreshRetryCount = 0;
                    if (manualRefreshRetryTimer) clearTimeout(manualRefreshRetryTimer);
                }
                
                allStocks = response.data;
                
                // Update watchlist with fresh data
                updateWatchlistWithFreshData();
                
                // Preserve current search filter
                if (currentSearchTerm) {
                    filteredStocks = allStocks.filter(stock => {
                        return Object.values(stock).some(value => 
                            String(value).toLowerCase().includes(currentSearchTerm.toLowerCase())
                        );
                    });
                } else {
                    filteredStocks = [...allStocks];
                }
                
                // Reapply sorting if there's an active sort
                if (currentSortColumn) {
                    filteredStocks = sortData([...filteredStocks], currentSortColumn, currentSortDirection);
                }
                
                displayStocks();
                displayWatchlist();
                updateLastUpdated();
                updateRecordCounter();
            } catch (error) {
                console.error('Error refreshing data:', error);
                
                // If this is a manual refresh, retry indefinitely on error too
                if (isManualRefresh) {
                    console.log(`üîÑ Manual refresh error - retrying in 5 seconds... (attempt ${manualRefreshRetryCount}, will keep trying)`);
                    if (manualRefreshRetryTimer) clearTimeout(manualRefreshRetryTimer);
                    manualRefreshRetryTimer = setTimeout(() => {
                        refreshQueriesAndData(true); // Retry manual refresh on error
                    }, 5000);
                } else {
                showStatus('Error refreshing data: ' + error.message, 'error');
                // Hide loading spinner on error
                const loadingSpinner = document.getElementById('loadingSpinner');
                if (loadingSpinner) {
                    loadingSpinner.style.display = 'none';
                    }
                }
            }
        }

        function backupWalletData() {
            try {
                // Create backup data object with portfolio and transactions
                const backupData = {
                    version: '0.9.2',
                    timestamp: new Date().toISOString(),
                    portfolio: portfolio,
                    transactions: transactions
                };
                
                // Convert to JSON
                const jsonContent = JSON.stringify(backupData, null, 2);
                const blob = new Blob([jsonContent], { type: 'application/json;charset=utf-8;' });
                
                // Create download link
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                
                // Create filename with timestamp
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
                link.setAttribute('download', `wallet-backup-${timestamp}.json`);
                
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                showStatus(`Wallet backup created successfully (${portfolio.length} holdings, ${transactions.length} transactions)`, 'success');
                console.log('üíæ Wallet backup created:', backupData);
            } catch (error) {
                console.error('Error creating wallet backup:', error);
                showStatus('Error creating backup: ' + error.message, 'error');
            }
        }

        function restoreWalletData() {
            // Trigger file input click
            document.getElementById('restoreFileInput').click();
        }

        let pendingRestoreData = null; // Store backup data for confirmation

        function handleRestoreFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            if (file.type !== 'application/json' && !file.name.endsWith('.json')) {
                showStatus('Please select a valid JSON backup file', 'error');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const jsonString = e.target.result;
                    if (!jsonString || jsonString.trim() === '') {
                        showStatus('Backup file is empty', 'error');
                        return;
                    }
                    
                    const backupData = JSON.parse(jsonString);
                    console.log('üìÑ Parsed backup data:', backupData);
                    
                    // Validate backup data structure
                    if (!backupData || typeof backupData !== 'object') {
                        showStatus('Invalid backup file format - not a valid object', 'error');
                        return;
                    }
                    
                    if (!backupData.hasOwnProperty('portfolio') || !backupData.hasOwnProperty('transactions')) {
                        showStatus('Invalid backup file format - missing required fields (portfolio, transactions)', 'error');
                        return;
                    }
                    
                    // Store backup data and show custom confirmation modal
                    pendingRestoreData = backupData;
                    showRestoreConfirmModal(backupData);
                    
                } catch (error) {
                    console.error('Error reading backup file:', error);
                    showStatus('Error reading backup file: ' + error.message, 'error');
                }
            };
            
            reader.onerror = function(error) {
                console.error('FileReader error:', error);
                showStatus('Error reading file: ' + error.message, 'error');
            };
            reader.readAsText(file);
            
            // Reset file input
            event.target.value = '';
        }

        function showRestoreConfirmModal(backupData) {
            // Populate backup info
            const backupInfo = document.getElementById('restoreBackupInfo');
            const backupDate = backupData.timestamp ? new Date(backupData.timestamp).toLocaleString() : 'Unknown';
            
            backupInfo.innerHTML = `
                <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                    <span>üìà Portfolio Holdings:</span>
                    <strong>${backupData.portfolio.length} items</strong>
                </div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                    <span>üìä Transaction Records:</span>
                    <strong>${backupData.transactions.length} transactions</strong>
                </div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                    <span>üìÖ Backup Created:</span>
                    <strong>${backupDate}</strong>
                </div>
                <div style="display: flex; justify-content: space-between;">
                    <span>üìã Backup Version:</span>
                    <strong>${backupData.version || 'Unknown'}</strong>
                </div>
            `;
            
            // Populate current info
            const currentInfo = document.getElementById('restoreCurrentInfo');
            currentInfo.innerHTML = `
                <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                    <span>üìà Current Portfolio:</span>
                    <strong>${portfolio.length} items</strong>
                </div>
                <div style="display: flex; justify-content: space-between;">
                    <span>üìä Current Transactions:</span>
                    <strong>${transactions.length} transactions</strong>
                </div>
            `;
            
            // Show modal
            document.getElementById('restoreConfirmModal').style.display = 'flex';
        }

        function hideRestoreConfirmModal() {
            document.getElementById('restoreConfirmModal').style.display = 'none';
            pendingRestoreData = null;
        }

        function confirmRestore() {
            if (pendingRestoreData) {
                const backupData = pendingRestoreData; // Store reference before clearing
                hideRestoreConfirmModal();
                restoreWalletFromBackup(backupData); // Use stored reference
            }
        }

        function restoreWalletFromBackup(backupData) {
            try {
                // Validate backup data
                if (!backupData) {
                    throw new Error('Backup data is null or undefined');
                }
                
                if (typeof backupData !== 'object') {
                    throw new Error('Invalid backup data format');
                }
                
                console.log('üîÑ Starting wallet restore with data:', backupData);
                
                // Restore portfolio data
                portfolio = Array.isArray(backupData.portfolio) ? backupData.portfolio : [];
                filteredPortfolio = [...portfolio];
                
                // Restore transactions data
                transactions = Array.isArray(backupData.transactions) ? backupData.transactions : [];
                
                // Save restored data to localStorage
                savePortfolio();
                saveTransactions();
                
                // Update displays
                displayPortfolio();
                displayTransactionHistory();
                updatePortfolioSummary();
                
                // Update filtered data if there's a search active
                if (currentWalletSearchTerm) {
                    filterPortfolio();
                }
                
                showStatus(`Wallet restored successfully (${portfolio.length} holdings, ${transactions.length} transactions)`, 'success');
                console.log('üì• Wallet restored from backup:', backupData);
                
                // Log restore details
                console.log(`üìä Restored ${portfolio.length} portfolio items`);
                console.log(`üìä Restored ${transactions.length} transactions`);
                
            } catch (error) {
                console.error('Error restoring wallet:', error);
                showStatus('Error restoring wallet: ' + error.message, 'error');
            }
        }

        // Legacy function for backward compatibility (if needed elsewhere)
        function exportData() {
            const csvContent = convertToCSV(filteredStocks);
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', 'egyptian_stocks.csv');
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            showStatus('Data exported successfully', 'success');
        }

        function convertToCSV(data) {
            if (data.length === 0) return '';
            
            const headers = Object.keys(data[0]);
            const csvRows = [headers.join(',')];
            
            data.forEach(row => {
                const values = headers.map(header => {
                    const value = row[header] || '';
                    return `"${value.toString().replace(/"/g, '""')}"`;
                });
                csvRows.push(values.join(','));
            });
            
            return csvRows.join('\n');
        }

        function showStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${type}`;
            status.style.display = 'block';
            
            setTimeout(() => {
                status.style.display = 'none';
            }, 3000);
        }

        function updateLastUpdated() {
            const now = new Date();
            const lastUpdatedElement = document.getElementById('lastUpdated');
            
            const timestamp = now.toLocaleString();
            lastUpdatedElement.textContent = `Last updated: ${timestamp}`;
            
            lastUpdatedElement.classList.remove('updating');
            
            // Hide loading spinner
            const loadingSpinner = document.getElementById('loadingSpinner');
            if (loadingSpinner) {
                loadingSpinner.style.display = 'none';
            }
        }

        function updateRecordCounter() {
            const recordCountElement = document.getElementById('recordCount');
            const totalStocks = allStocks ? allStocks.length : 0;
            const filteredStocksCount = filteredStocks ? filteredStocks.length : 0;
            
            if (totalStocks === 0) {
                recordCountElement.textContent = 'üìä Loading...';
                recordCountElement.style.color = '#ffa500';
            } else if (totalStocks === 2) {
                recordCountElement.textContent = `‚ö†Ô∏è Mock Data: ${totalStocks} records`;
                recordCountElement.style.color = '#ff6b6b';
            } else {
                recordCountElement.textContent = `üìä ${totalStocks} stocks loaded`;
                if (filteredStocksCount !== totalStocks) {
                    recordCountElement.textContent += ` (${filteredStocksCount} filtered)`;
                }
                recordCountElement.style.color = '#00bfff';
            }
        }

        function showUpdating() {
            const loadingSpinner = document.getElementById('loadingSpinner');
            if (loadingSpinner) {
                loadingSpinner.style.display = 'block';
            }
        }

        function startAutoRefresh() {
            // Auto-refresh with interval from settings
            loadRefreshInterval();
        }

        async function loadRefreshInterval() {
            try {
                const settings = await ipcRenderer.invoke('get-settings');
                const interval = (settings.updateInterval || 30) * 1000; // Convert seconds to milliseconds
                
                console.log(`‚è∞ Setting auto-refresh interval to ${settings.updateInterval || 30} seconds`);
                
                // Clear any existing interval
                if (window.refreshIntervalId) {
                    clearInterval(window.refreshIntervalId);
                }
                
                // Set new interval - but check market status first
                window.refreshIntervalId = setInterval(async () => {
                    // Check if auto-update is enabled
                    const settings = await ipcRenderer.invoke('get-settings');
                    if (!settings.autoUpdateEnabled) {
                        console.log('üîÑ Auto-update is disabled - skipping refresh');
                        return;
                    }
                    
                    // Check market status before auto-refreshing
                    if (currentMarketStatus && currentMarketStatus.status === 'closed') {
                        console.log('üî¥ Market is closed - skipping auto refresh');
                        return;
                    }
                    
                    refreshQueriesAndData();
                }, interval);
            } catch (error) {
                console.error('Error loading refresh interval:', error);
                // Fallback to 30 seconds
                window.refreshIntervalId = setInterval(async () => {
                    // Check market status before auto-refreshing
                    if (currentMarketStatus && currentMarketStatus.status === 'closed') {
                        console.log('üî¥ Market is closed - skipping auto refresh (fallback)');
                        return;
                    }
                    
                    refreshQueriesAndData();
                }, 30000);
            }
        }

        function updateWatchlistWithFreshData() {
            if (watchlist.length === 0 || allStocks.length === 0) {
                return;
            }

            console.log('üîÑ Updating watchlist with fresh data...');
            console.log('üìä Watchlist before update:', watchlist.length, 'stocks');
            console.log('üìä Fresh data available:', allStocks.length, 'stocks');

            // Create a map of fresh data by stock name for quick lookup
            const freshDataMap = new Map();
            allStocks.forEach(stock => {
                const stockName = stock['ÿßŸÑÿ•ÿ≥ŸÖ_ÿßŸÑŸÖÿÆÿ™ÿµÿ±'];
                if (stockName) {
                    freshDataMap.set(stockName, stock);
                }
            });

            // Update watchlist with fresh data
            let updatedCount = 0;
            watchlist.forEach((watchlistStock, index) => {
                const stockName = watchlistStock['ÿßŸÑÿ•ÿ≥ŸÖ_ÿßŸÑŸÖÿÆÿ™ÿµÿ±'];
                if (stockName && freshDataMap.has(stockName)) {
                    const freshStock = freshDataMap.get(stockName);
                    watchlist[index] = freshStock;
                    updatedCount++;
                }
            });

            // Update filtered watchlist
            if (currentWatchlistSearchTerm) {
                filteredWatchlist = watchlist.filter(stock => {
                    return Object.values(stock).some(value => 
                        String(value).toLowerCase().includes(currentWatchlistSearchTerm.toLowerCase())
                    );
                });
            } else {
                filteredWatchlist = [...watchlist];
            }

            // Reapply sorting if there's an active sort
            if (watchlistSortColumn) {
                filteredWatchlist = sortData([...filteredWatchlist], watchlistSortColumn, watchlistSortDirection);
            }

            // Save updated watchlist
            saveWatchlist();

            console.log(`‚úÖ Watchlist updated: ${updatedCount}/${watchlist.length} stocks refreshed with fresh data`);
        }

        function updatePortfolioWithFreshData() {
            if (portfolio.length === 0 || allStocks.length === 0) {
                return;
            }

            console.log('üîÑ Updating portfolio with fresh data...');
            console.log('üìä Portfolio before update:', portfolio.length, 'stocks');
            console.log('üìä Fresh data available:', allStocks.length, 'stocks');

            // Update portfolio summary and display
            updatePortfolioSummary();
            displayPortfolio();
            displayTransactionHistory(); // Also refresh transaction history

            console.log(`‚úÖ Portfolio updated with fresh data`);
        }

        // Listen for real-time updates from main process
        ipcRenderer.on('stock-data-updated', (event, data) => {
            // Check if we have mock data (2 records)
            if (data && data.length === 2) {
                console.log('‚ö†Ô∏è Mock data detected in stock-data-updated (2 records)');
                
                // If we're in startup phase, trigger retry logic
                if (isStartupPhase && allStocks.length === 0) {
                    startupRetryCount++;
                    console.log(`üîÑ Startup phase - mock data retry ${startupRetryCount} (will keep trying until success)`);
                    console.log(`üîÑ Retrying startup data load in 3 seconds...`);
                    
                    if (startupRetryTimer) clearTimeout(startupRetryTimer);
                    startupRetryTimer = setTimeout(() => {
                        startupDataLoad();
                    }, 3000);
                    return;
                } else {
                    // Not in startup phase or have existing data - just show warning
                    console.log('üìä Not in startup phase - keeping existing data');
                    updateRecordCounter();
                    return;
                }
            }
            
            // Normal data - update as usual
            console.log(`‚úÖ Real data received: ${data.length} records`);
            if (isStartupPhase) {
                console.log('üéØ Startup phase completed successfully');
                isStartupPhase = false;
                startupRetryCount = 0;
                if (startupRetryTimer) clearTimeout(startupRetryTimer);
            }
            
            allStocks = data;
            
            // Update watchlist with fresh data
            updateWatchlistWithFreshData();
            
            // Update portfolio with fresh data
            updatePortfolioWithFreshData();
            
            // Preserve current search filter
            if (currentSearchTerm) {
                filteredStocks = allStocks.filter(stock => {
                    return Object.values(stock).some(value => 
                        String(value).toLowerCase().includes(currentSearchTerm.toLowerCase())
                    );
                });
            } else {
                filteredStocks = [...allStocks];
            }
            
            // Reapply sorting if there's an active sort
            if (currentSortColumn) {
                filteredStocks = sortData([...filteredStocks], currentSortColumn, currentSortDirection);
            }
            
            initializeColumnVisibility();
            displayStocks();
            displayWatchlist();
            updateLastUpdated();
            updateRecordCounter();
        });

        ipcRenderer.on('stock-data-error', (event, error) => {
            showStatus('Error: ' + error, 'error');
        });

        // Auto-updater event listeners
        ipcRenderer.on('update-checking', () => {
            console.log('Checking for updates...');
        });

        ipcRenderer.on('update-available', (event, info) => {
            console.log('Update available:', info);
            // Close settings modal if it's open
            hideSettingsModal();
            showUpdateAvailableModal(info);
        });

        ipcRenderer.on('update-not-available', (event, info) => {
            console.log('No updates available:', info);
            showStatus('You are using the latest version', 'info');
        });

        ipcRenderer.on('update-error', (event, error) => {
            console.error('Update error:', error);
            showStatus('Update error: ' + error, 'error');
        });

        // Handle open-settings event from tray
        ipcRenderer.on('open-settings', () => {
            showSettingsModal();
        });

        // Handle market status updates
        ipcRenderer.on('market-status-updated', (event, data) => {
            console.log('Market status updated:', data);
            currentMarketStatus = data; // Store the current market status
            updateMarketStatusIndicator(data);
        });
        
        // Listen for widget checkbox updates from tray
        ipcRenderer.on('update-widget-checkbox', (event, enabled) => {
            const widgetEnabledCheckbox = document.getElementById('widgetEnabled');
            if (widgetEnabledCheckbox) {
                widgetEnabledCheckbox.checked = enabled;
            }
        });
        
        // Function to send watchlist data to widget
        function sendWatchlistToWidget() {
            try {
                // Get the entire table HTML
                const table = document.querySelector('#watchlistTable');
                const tableBody = document.querySelector('#watchlistTableBody');

                console.log('Table found:', !!table);
                console.log('Table display style:', table ? table.style.display : 'N/A');
                console.log('TableBody found:', !!tableBody);

                if (tableBody) {
                    const rows = tableBody.querySelectorAll('tr');
                    console.log('Table rows count:', rows.length);

                    const dataRows = Array.from(rows).filter(row => {
                        const cells = row.querySelectorAll('td');
                        return cells.length > 0 && cells[0].textContent.trim() !== '';
                    });
                    console.log('Data rows count:', dataRows.length);
                }

                if (!table || !tableBody) {
                    console.log('No watchlist table or body found');
                    showStatus('No watchlist table found', 'error');
                    return;
                }

                // Make sure the table is visible before copying
                const originalDisplay = table.style.display;
                table.style.display = 'table';

                try {
                    // Clone the table and get its HTML
                    const clonedTable = table.cloneNode(true);
                    const tableHTML = clonedTable.outerHTML;

                    console.log('Sending table HTML to widget, length:', tableHTML.length);

                    // Restore original display style
                    table.style.display = originalDisplay;

                    ipcRenderer.invoke('send-table-to-widget', tableHTML);
                } catch (error) {
                    // Restore original display style
                    table.style.display = originalDisplay;
                    throw error;
                }
            } catch (error) {
                console.error('Error sending table to widget:', error);
                showStatus('Error sending table: ' + error.message, 'error');
            }
        }
        
        // Function to test widget communication
        async function testWidgetCommunication() {
            try {
                console.log('Testing widget communication...');
                const result = await ipcRenderer.invoke('test-widget-communication');
                if (result.success) {
                    showStatus('Test message sent to widget!', 'success');
                } else {
                    showStatus('Test failed: ' + result.error, 'error');
                }
            } catch (error) {
                console.error('Error testing widget communication:', error);
                showStatus('Test error: ' + error.message, 'error');
            }
        }
        
        // Function to create test widget
        async function createTestWidget() {
            try {
                console.log('Creating test widget...');
                const result = await ipcRenderer.invoke('create-test-widget');
                if (result.success) {
                    showStatus('Test widget created!', 'success');
                } else {
                    showStatus('Test widget failed: ' + result.error, 'error');
                }
            } catch (error) {
                console.error('Error creating test widget:', error);
                showStatus('Test widget error: ' + error.message, 'error');
            }
        }

        // Calculate next market opening time
        function getNextMarketOpeningTime(marketData) {
            const now = new Date();
            const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
            
            // Get market settings from the data or use defaults
            const openTime = marketData.openTime || { hour: 10, minute: 0 };
            const closeTime = marketData.closeTime || { hour: 14, minute: 30 };
            const daysOff = marketData.daysOff || { friday: true, saturday: true };
            
            const currentDay = dayNames[now.getDay()];
            const currentTime = now.getHours() * 60 + now.getMinutes();
            const marketOpenTime = openTime.hour * 60 + openTime.minute;
            const marketCloseTime = closeTime.hour * 60 + closeTime.minute;
            
            // If today is a day off, find next trading day
            if (daysOff[currentDay]) {
                let daysToAdd = 1;
                while (daysToAdd <= 7) { // Prevent infinite loop
                    const checkDate = new Date(now);
                    checkDate.setDate(now.getDate() + daysToAdd);
                    const dayName = dayNames[checkDate.getDay()];
                    
                    // If this day is not a day off
                    if (!daysOff[dayName]) {
                        const nextOpenDate = new Date(checkDate);
                        nextOpenDate.setHours(openTime.hour, openTime.minute, 0, 0);
                        return nextOpenDate;
                    }
                    daysToAdd++;
                }
            }
            
            // If market hasn't opened yet today
            if (currentTime < marketOpenTime) {
                const todayOpenDate = new Date(now);
                todayOpenDate.setHours(openTime.hour, openTime.minute, 0, 0);
                return todayOpenDate;
            }
            
            // If market is closed for the day (after hours), find next trading day
            if (currentTime >= marketCloseTime) {
                let daysToAdd = 1;
                while (daysToAdd <= 7) { // Prevent infinite loop
                    const checkDate = new Date(now);
                    checkDate.setDate(now.getDate() + daysToAdd);
                    const dayName = dayNames[checkDate.getDay()];
                    
                    // If this day is not a day off
                    if (!daysOff[dayName]) {
                        const nextOpenDate = new Date(checkDate);
                        nextOpenDate.setHours(openTime.hour, openTime.minute, 0, 0);
                        return nextOpenDate;
                    }
                    daysToAdd++;
                }
            }
            
            return null; // Should never reach here
        }

        // Format countdown display
        function formatCountdown(targetDate) {
            const now = new Date();
            const diff = targetDate.getTime() - now.getTime();
            
            if (diff <= 0) {
                return "Market Opening Soon!";
            }
            
            const days = Math.floor(diff / (1000 * 60 * 60 * 24));
            const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((diff % (1000 * 60)) / 1000);
            
            let countdown = "";
            if (days > 0) {
                countdown += `${days}d `;
            }
            if (hours > 0 || days > 0) {
                countdown += `${hours}h `;
            }
            if (minutes > 0 || hours > 0 || days > 0) {
                countdown += `${minutes}m `;
            }
            countdown += `${seconds}s`;
            
            return countdown;
        }

        // Update market status indicator in header
        function updateMarketStatusIndicator(data) {
            const marketStatusElement = document.getElementById('marketStatus');
            const countdownElement = document.getElementById('marketCountdown');
            if (!marketStatusElement) return;

            // Store the market status globally
            currentMarketStatus = data;

            // Remove all existing classes
            marketStatusElement.className = 'market-status-indicator';
            
            if (data.status === 'open') {
                marketStatusElement.textContent = 'üü¢ Market Open';
                marketStatusElement.classList.add('open');
                // Hide countdown when market is open
                if (countdownElement) {
                    countdownElement.style.display = 'none';
                }
            } else if (data.status === 'closed') {
                if (data.isDayOff) {
                    marketStatusElement.textContent = 'üî¥ Market Closed (Day Off)';
                } else {
                    marketStatusElement.textContent = 'üî¥ Market Closed';
                }
                marketStatusElement.classList.add('closed');
                
                // Show countdown when market is closed
                if (countdownElement) {
                    countdownElement.style.display = 'inline';
                    updateCountdownDisplay();
                }
            } else {
                marketStatusElement.textContent = 'üìä Loading...';
                marketStatusElement.classList.add('loading');
                // Hide countdown when loading
                if (countdownElement) {
                    countdownElement.style.display = 'none';
                }
            }
        }

        // Update countdown display
        function updateCountdownDisplay() {
            if (!currentMarketStatus || currentMarketStatus.status !== 'closed') {
                return;
            }
            
            const countdownElement = document.getElementById('marketCountdown');
            if (!countdownElement) return;
            
            const nextOpening = getNextMarketOpeningTime(currentMarketStatus);
            if (nextOpening) {
                const countdown = formatCountdown(nextOpening);
                countdownElement.textContent = `‚è∞ Opens in: ${countdown}`;
            } else {
                countdownElement.textContent = '‚è∞ Opening time unavailable';
            }
        }

        // News System
        let newsData = [];
        let lastNewsCheck = 0;
        let newsLoadedOnStartup = false;

        // News sources configuration
        const NEWS_SOURCES = {
            github: {
                url: 'https://api.github.com/repos/AMoussa77/The-Egyptian-Exchange/releases',
                type: 'github'
            },
            // Local news file (you can edit news.json directly)
            local: {
                url: './news.json',
                type: 'json'
            }
            // You can add more sources here
            // custom: {
            //     url: 'https://your-domain.com/api/news.json',
            //     type: 'json'
            // }
        };

        // Load news from multiple sources (only once at startup)
        async function loadNews(forceRefresh = false) {
            // Only load news once at startup unless manually refreshed
            if (newsLoadedOnStartup && !forceRefresh) {
                console.log('üì∞ News already loaded, showing cached data');
                displayNews(newsData);
                return;
            }
            
            console.log('üì∞ Loading news from sources...');
            showNewsLoading();
            
            try {
                const newsPromises = Object.values(NEWS_SOURCES).map(source => fetchNewsFromSource(source));
                const results = await Promise.allSettled(newsPromises);
                
                let allNews = [];
                results.forEach((result, index) => {
                    if (result.status === 'fulfilled' && result.value) {
                        allNews = allNews.concat(result.value);
                    } else {
                        console.warn(`Failed to fetch news from source ${index}:`, result.reason);
                    }
                });
                
                // Sort news by date (newest first)
                allNews.sort((a, b) => new Date(b.date) - new Date(a.date));
                
                newsData = allNews;
                displayNews(newsData);
                
                // Mark as loaded and store cache
                newsLoadedOnStartup = true;
                lastNewsCheck = Date.now();
                localStorage.setItem('lastNewsCheck', lastNewsCheck.toString());
                localStorage.setItem('cachedNews', JSON.stringify(newsData));
                
                console.log(`üì∞ News loaded successfully: ${newsData.length} items`);
                
            } catch (error) {
                console.error('‚ùå Error loading news:', error);
                showNewsError();
            }
        }

        // Fetch news from a specific source
        async function fetchNewsFromSource(source) {
            try {
                if (source.type === 'github') {
                    return await fetchGitHubNews(source.url);
                } else if (source.type === 'json') {
                    return await fetchJSONNews(source.url);
                }
            } catch (error) {
                console.error(`Error fetching from ${source.type} source:`, error);
                return [];
            }
        }

        // Fetch news from GitHub releases
        async function fetchGitHubNews(url) {
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const releases = await response.json();
            return releases.slice(0, 10).map(release => ({
                id: `github-${release.id}`,
                title: `üì¶ ${release.name || release.tag_name}`,
                content: release.body || 'New version released',
                category: release.prerelease ? 'beta' : 'update',
                date: release.published_at,
                source: 'GitHub Releases',
                url: release.html_url,
                isNew: isNewsNew(release.published_at)
            }));
        }

        // Fetch news from JSON endpoint
        async function fetchJSONNews(url) {
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const data = await response.json();
            return data.news || data; // Support both {news: [...]} and [...] formats
        }

        // Check if news item is new (within last 7 days)
        function isNewsNew(dateString) {
            const newsDate = new Date(dateString);
            const weekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
            return newsDate > weekAgo;
        }

        // Display news in the UI
        function displayNews(news) {
            const newsContent = document.getElementById('newsContent');
            const newsList = document.getElementById('newsList');
            const newsLoading = document.getElementById('newsLoading');
            const newsError = document.getElementById('newsError');
            const newsEmpty = document.getElementById('newsEmpty');
            
            // Hide all states
            newsLoading.style.display = 'none';
            newsError.style.display = 'none';
            newsEmpty.style.display = 'none';
            
            if (!news || news.length === 0) {
                newsEmpty.style.display = 'block';
                newsContent.style.display = 'none';
                return;
            }
            
            // Generate news HTML
            newsList.innerHTML = news.map(item => createNewsItemHTML(item)).join('');
            newsContent.style.display = 'block';
            
            console.log(`üì∞ Displayed ${news.length} news items`);
        }

        // Create HTML for a single news item
        function createNewsItemHTML(item) {
            const categoryClass = item.category ? item.category.toLowerCase() : 'general';
            const isNew = item.isNew ? 'new' : '';
            const newBadge = item.isNew ? '<span class="news-badge new">New</span>' : '';
            
            return `
                <div class="news-item ${categoryClass}">
                    <div class="news-header-info">
                        <div>
                            <h3 class="news-title">${item.title}${newBadge}</h3>
                        </div>
                        <span class="news-category ${categoryClass}">${item.category || 'News'}</span>
                    </div>
                    
                    <div class="news-content">
                        ${formatNewsContent(item.content)}
                    </div>
                    
                    <div class="news-meta">
                        <div class="news-date">
                            <span>üìÖ</span>
                            <span>${formatNewsDate(item.date)}</span>
                        </div>
                        <div class="news-source">
                            <span>üì°</span>
                            <span>${item.source || 'Unknown'}</span>
                        </div>
                    </div>
                    
                    ${item.url ? `
                        <div class="news-actions">
                            <a href="${item.url}" class="news-btn" onclick="openExternal('${item.url}'); return false;">
                                üîó Read More
                            </a>
                        </div>
                    ` : ''}
                </div>
            `;
        }

        // Format news content (convert markdown-like syntax to HTML)
        function formatNewsContent(content) {
            if (!content) return '';
            
            // Convert basic markdown to HTML
            return content
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>') // Bold
                .replace(/\*(.*?)\*/g, '<em>$1</em>') // Italic
                .replace(/`(.*?)`/g, '<code>$1</code>') // Code
                .replace(/\n/g, '<br>') // Line breaks
                .substring(0, 500) + (content.length > 500 ? '...' : ''); // Truncate long content
        }

        // Format news date
        function formatNewsDate(dateString) {
            const date = new Date(dateString);
            const now = new Date();
            const diffTime = Math.abs(now - date);
            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
            
            if (diffDays === 1) {
                return 'Today';
            } else if (diffDays === 2) {
                return 'Yesterday';
            } else if (diffDays <= 7) {
                return `${diffDays - 1} days ago`;
            } else {
                return date.toLocaleDateString();
            }
        }

        // Show loading state
        function showNewsLoading() {
            document.getElementById('newsLoading').style.display = 'block';
            document.getElementById('newsContent').style.display = 'none';
            document.getElementById('newsError').style.display = 'none';
            document.getElementById('newsEmpty').style.display = 'none';
        }

        // Show error state
        function showNewsError() {
            document.getElementById('newsLoading').style.display = 'none';
            document.getElementById('newsContent').style.display = 'none';
            document.getElementById('newsError').style.display = 'block';
            document.getElementById('newsEmpty').style.display = 'none';
        }

        // Refresh news manually (force refresh from sources)
        async function refreshNews() {
            const refreshBtn = document.getElementById('refreshNewsBtn');
            const originalText = refreshBtn.textContent;
            
            refreshBtn.textContent = 'üîÑ Refreshing...';
            refreshBtn.disabled = true;
            
            try {
                await loadNews(true); // Force refresh from sources
                showStatus('News refreshed successfully!', 'success');
            } catch (error) {
                console.error('Error refreshing news:', error);
                showStatus('Failed to refresh news', 'error');
            } finally {
                refreshBtn.textContent = originalText;
                refreshBtn.disabled = false;
            }
        }

        // Open external links
        function openExternal(url) {
            if (typeof require !== 'undefined') {
                // Electron environment
                const { shell } = require('electron');
                shell.openExternal(url);
            } else {
                // Browser environment
                window.open(url, '_blank');
            }
        }

        // News is only loaded once at startup
        // No automatic periodic refresh to save API calls

        // Check for new news items (used only during manual refresh)
        function checkForNewNewsItems(oldNewsData, newNewsData) {
            const oldNewsIds = oldNewsData.map(item => item.id);
            const newItems = newNewsData.filter(item => !oldNewsIds.includes(item.id));
            
            if (newItems.length > 0) {
                console.log(`üì∞ Found ${newItems.length} new news items`);
                
                // Show notification for new news
                const message = newItems.length === 1 
                    ? `üì∞ New: ${newItems[0].title}`
                    : `üì∞ ${newItems.length} new news updates available`;
                
                showStatus(message, 'info');
                
                // Show notification dot on news icon
                showNewsNotificationDot();
                
                // Play notification sound if enabled
                if (typeof playNotificationSound === 'function') {
                    playNotificationSound();
                }
            }
        }

        // Show notification dot on news icon
        function showNewsNotificationDot() {
            const dot = document.getElementById('newsNotificationDot');
            if (dot) {
                dot.style.display = 'block';
            }
        }

        // Hide notification dot from news icon
        function hideNewsNotificationDot() {
            const dot = document.getElementById('newsNotificationDot');
            if (dot) {
                dot.style.display = 'none';
            }
        }

        // Load cached news on startup
        function loadCachedNews() {
            try {
                const cached = localStorage.getItem('cachedNews');
                const lastCheck = localStorage.getItem('lastNewsCheck');
                
                if (cached && lastCheck) {
                    newsData = JSON.parse(cached);
                    lastNewsCheck = parseInt(lastCheck);
                    
                    // Show cached news immediately
                    displayNews(newsData);
                    console.log('üì∞ Loaded cached news');
                }
            } catch (error) {
                console.error('Error loading cached news:', error);
            }
        }

        // Exchange News System
        let exchangeNewsData = [];
        let exchangeNewsLoaded = false;

        // Load Exchange News from Mubasher.info
        async function loadExchangeNews(forceRefresh = false) {
            // Only load once unless manually refreshed
            if (exchangeNewsLoaded && !forceRefresh) {
                console.log('üì∞ Exchange news already loaded, showing cached data');
                displayExchangeNews(exchangeNewsData);
                return;
            }
            
            console.log('üì∞ Loading exchange news from Mubasher.info...');
            showExchangeNewsLoading();
            
            try {
                // Fetch real exchange news from main process (bypasses CORS)
                const result = await ipcRenderer.invoke('fetch-exchange-news');
                
                if (result.success && result.data) {
                    exchangeNewsData = result.data;
                } else {
                    // Fallback to mock data if scraping fails
                    exchangeNewsData = await fetchMockExchangeNews();
                }
                
                displayExchangeNews(exchangeNewsData);
                
                // Mark as loaded and cache
                exchangeNewsLoaded = true;
                localStorage.setItem('cachedExchangeNews', JSON.stringify(exchangeNewsData));
                localStorage.setItem('lastExchangeNewsCheck', Date.now().toString());
                
                console.log(`üì∞ Exchange news loaded: ${exchangeNewsData.length} announcements`);
                
            } catch (error) {
                console.error('‚ùå Error loading exchange news:', error);
                showExchangeNewsError();
            }
        }

        // Fetch mock exchange news (simulating Mubasher.info structure)
        async function fetchMockExchangeNews() {
            // Simulate API delay
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            // Mock data based on Mubasher.info structure
            return [
                {
                    id: 'egx-001',
                    title: 'ÿßŸÑÿÆÿØŸÖÿßÿ™ ÿßŸÑŸÖŸÑÿßÿ≠Ÿäÿ© ŸàÿßŸÑÿ®ÿ™ÿ±ŸàŸÑŸäÿ© ŸÖÿßÿ±ŸäÿØÿßŸäŸÅ (MOIL.CA) ŸÇÿ±ÿßÿ± ŸÑÿ¨ŸÜÿ© ÿßŸÑŸÇŸäÿØ',
                    content: 'ŸÇÿ±ÿßÿ± ŸÑÿ¨ŸÜÿ© ÿßŸÑŸÇŸäÿØ ÿ®ÿ¨ŸÑÿ≥ÿ™Ÿáÿß ÿßŸÑŸÖŸÜÿπŸÇÿØÿ© ÿ®ÿ™ÿßÿ±ŸäÿÆ 01/10/2025 - ÿßÿ≥ŸÖ ÿßŸÑÿ¥ÿ±ŸÉÿ©: ÿßŸÑÿÆÿØŸÖÿßÿ™ ÿßŸÑŸÖŸÑÿßÿ≠Ÿäÿ© ŸàÿßŸÑÿ®ÿ™ÿ±ŸàŸÑŸäÿ© ŸÖÿßÿ±ŸäÿØÿßŸäŸÅ',
                    company: 'MOIL.CA',
                    date: new Date().toISOString(),
                    source: 'ÿßŸÑÿ®Ÿàÿ±ÿµÿ© ÿßŸÑŸÖÿµÿ±Ÿäÿ©',
                    category: 'announcement',
                    isNew: true
                },
                {
                    id: 'egx-002',
                    title: 'ÿßÿ≥ÿ®ÿßŸäÿ± ŸÉÿßÿ®Ÿäÿ™ÿßŸÑ ÿßŸÑŸÇÿßÿ®ÿ∂ÿ© ŸÑŸÑÿßÿ≥ÿ™ÿ´ŸÖÿßÿ±ÿßÿ™ ÿßŸÑŸÖÿßŸÑŸäÿ© (ASPI.CA) ŸÇÿ±ÿßÿ± ŸÑÿ¨ŸÜÿ© ÿßŸÑŸÇŸäÿØ',
                    content: 'ŸÇÿ±ÿßÿ± ŸÑÿ¨ŸÜÿ© ÿßŸÑŸÇŸäÿØ ÿ®ÿ¨ŸÑÿ≥ÿ™Ÿáÿß ÿßŸÑŸÖŸÜÿπŸÇÿØÿ© ÿ®ÿ™ÿßÿ±ŸäÿÆ 01/10/2025 - ÿßÿ≥ŸÖ ÿßŸÑÿ¥ÿ±ŸÉÿ©: ÿßÿ≥ÿ®ÿßŸäÿ± ŸÉÿßÿ®Ÿäÿ™ÿßŸÑ ÿßŸÑŸÇÿßÿ®ÿ∂ÿ© ŸÑŸÑÿßÿ≥ÿ™ÿ´ŸÖÿßÿ±ÿßÿ™ ÿßŸÑŸÖÿßŸÑŸäÿ©',
                    company: 'ASPI.CA',
                    date: new Date(Date.now() - 60000).toISOString(),
                    source: 'ÿßŸÑÿ®Ÿàÿ±ÿµÿ© ÿßŸÑŸÖÿµÿ±Ÿäÿ©',
                    category: 'announcement',
                    isNew: true
                },
                {
                    id: 'egx-003',
                    title: 'ÿßŸÑÿπÿ±ÿ®Ÿäÿ© ŸÑŸÑŸÖÿ≠ÿßÿ®ÿ≥ (ARVA.CA) ŸÇÿ±ÿßÿ± ŸÑÿ¨ŸÜÿ© ÿßŸÑŸÇŸäÿØ',
                    content: 'ŸÇÿ±ÿßÿ± ŸÑÿ¨ŸÜÿ© ÿßŸÑŸÇŸäÿØ ÿ®ÿ¨ŸÑÿ≥ÿ™Ÿáÿß ÿßŸÑŸÖŸÜÿπŸÇÿØÿ© ÿ®ÿ™ÿßÿ±ŸäÿÆ 01/10/2025 - ÿßÿ≥ŸÖ ÿßŸÑÿ¥ÿ±ŸÉÿ©: ÿßŸÑÿπÿ±ÿ®Ÿäÿ© ŸÑŸÑŸÖÿ≠ÿßÿ®ÿ≥ - ŸÉŸàÿØ ÿßŸÑÿ™ÿ±ŸÇŸäŸÖ ÿßŸÑÿØŸàŸÑŸä: EGS3E',
                    company: 'ARVA.CA',
                    date: new Date(Date.now() - 120000).toISOString(),
                    source: 'ÿßŸÑÿ®Ÿàÿ±ÿµÿ© ÿßŸÑŸÖÿµÿ±Ÿäÿ©',
                    category: 'announcement',
                    isNew: true
                },
                {
                    id: 'egx-004',
                    title: 'ÿßŸÑŸÜÿµÿ± ŸÑÿ™ÿµŸÜŸäÿπ ÿßŸÑÿ≠ÿßÿµŸÑÿßÿ™ ÿßŸÑÿ≤ÿ±ÿßÿπŸäÿ© (ELNA.CA) ŸÇÿ±ÿßÿ± ŸÑÿ¨ŸÜÿ© ÿßŸÑŸÇŸäÿØ',
                    content: 'ŸÇÿ±ÿßÿ± ŸÑÿ¨ŸÜÿ© ÿßŸÑŸÇŸäÿØ ÿ®ÿ¨ŸÑÿ≥ÿ™Ÿáÿß ÿßŸÑŸÖŸÜÿπŸÇÿØÿ© ÿ®ÿ™ÿßÿ±ŸäÿÆ 01/10/2025 - ÿßÿ≥ŸÖ ÿßŸÑÿ¥ÿ±ŸÉÿ©: ÿßŸÑŸÜÿµÿ± ŸÑÿ™ÿµŸÜŸäÿπ ÿßŸÑÿ≠ÿßÿµŸÑÿßÿ™ ÿßŸÑÿ≤ÿ±ÿßÿπŸäÿ©',
                    company: 'ELNA.CA',
                    date: new Date(Date.now() - 180000).toISOString(),
                    source: 'ÿßŸÑÿ®Ÿàÿ±ÿµÿ© ÿßŸÑŸÖÿµÿ±Ÿäÿ©',
                    category: 'official',
                    isNew: false
                }
            ];
        }

        // Display exchange news
        function displayExchangeNews(news) {
            const newsContent = document.getElementById('exchangeNewsContent');
            const newsList = document.getElementById('exchangeNewsList');
            const newsLoading = document.getElementById('exchangeNewsLoading');
            const newsError = document.getElementById('exchangeNewsError');
            const newsEmpty = document.getElementById('exchangeNewsEmpty');
            
            // Hide all states
            newsLoading.style.display = 'none';
            newsError.style.display = 'none';
            newsEmpty.style.display = 'none';
            
            if (!news || news.length === 0) {
                newsEmpty.style.display = 'block';
                newsContent.style.display = 'none';
                return;
            }
            
            // Generate news HTML
            newsList.innerHTML = news.map(item => createExchangeNewsItemHTML(item)).join('');
            newsContent.style.display = 'block';
            
            console.log(`üì∞ Displayed ${news.length} exchange announcements`);
        }

        // Create HTML for exchange news item
        function createExchangeNewsItemHTML(item) {
            const categoryClass = item.category || 'announcement';
            const newBadge = item.isNew ? '<span class="exchange-news-badge new">ÿ¨ÿØŸäÿØ</span>' : '';
            
            return `
                <div class="exchange-news-item ${categoryClass}" onclick="openExchangeNewsLink('${item.url}')" style="cursor: pointer;">
                    <div class="exchange-news-header-info">
                        <div>
                            <h3 class="exchange-news-title">${item.title}${newBadge}</h3>
                        </div>
                        <span class="exchange-news-company">${item.company || 'EGX'}</span>
                    </div>
                    
                    <div class="exchange-news-content">
                        ${item.content}
                    </div>
                    
                    <div class="exchange-news-meta">
                        <div class="exchange-news-date">
                            <span>üìÖ</span>
                            <span>${formatExchangeNewsDate(item.date, item)}</span>
                        </div>
                        <div class="exchange-news-source">
                            <span>üì°</span>
                            <span>${item.source || 'ÿßŸÑÿ®Ÿàÿ±ÿµÿ© ÿßŸÑŸÖÿµÿ±Ÿäÿ©'}</span>
                        </div>
                        <div class="exchange-news-link">
                            <span>üîó</span>
                            <span>ÿßÿ∂ÿ∫ÿ∑ ŸÑŸÑŸÇÿ±ÿßÿ°ÿ© ŸÉÿßŸÖŸÑÿ©</span>
                        </div>
                    </div>
                </div>
            `;
        }

        // Format exchange news date
        function formatExchangeNewsDate(dateString, item) {
            // If item has displayDate (relative time), use it as-is
            if (item && item.displayDate) {
                return item.displayDate;
            }
            
            const date = new Date(dateString);
            
            // Arabic month names
            const arabicMonths = [
                'ŸäŸÜÿßŸäÿ±', 'ŸÅÿ®ÿ±ÿßŸäÿ±', 'ŸÖÿßÿ±ÿ≥', 'ÿ£ÿ®ÿ±ŸäŸÑ', 'ŸÖÿßŸäŸà', 'ŸäŸàŸÜŸäŸà',
                'ŸäŸàŸÑŸäŸà', 'ÿ£ÿ∫ÿ≥ÿ∑ÿ≥', 'ÿ≥ÿ®ÿ™ŸÖÿ®ÿ±', 'ÿ£ŸÉÿ™Ÿàÿ®ÿ±', 'ŸÜŸàŸÅŸÖÿ®ÿ±', 'ÿØŸäÿ≥ŸÖÿ®ÿ±'
            ];
            
            const day = date.getDate();
            const month = arabicMonths[date.getMonth()];
            const year = date.getFullYear();
            const hours = date.getHours();
            const minutes = date.getMinutes().toString().padStart(2, '0');
            
            // Convert to 12-hour format with Arabic AM/PM
            let displayHour = hours;
            let ampm = 'ÿµ'; // ÿµÿ®ÿßÿ≠ÿßŸã (AM)
            
            if (hours === 0) {
                displayHour = 12;
                ampm = 'ÿµ';
            } else if (hours === 12) {
                displayHour = 12;
                ampm = 'ŸÖ'; // ŸÖÿ≥ÿßÿ°Ÿã (PM)
            } else if (hours > 12) {
                displayHour = hours - 12;
                ampm = 'ŸÖ';
            }
            
            // Format similar to Mubasher.info: "1 ÿ£ŸÉÿ™Ÿàÿ®ÿ± 03:28 ŸÖ"
            return `${day} ${month} ${displayHour.toString().padStart(2, '0')}:${minutes} ${ampm}`;
        }

        // Show loading state for exchange news
        function showExchangeNewsLoading() {
            document.getElementById('exchangeNewsLoading').style.display = 'block';
            document.getElementById('exchangeNewsContent').style.display = 'none';
            document.getElementById('exchangeNewsError').style.display = 'none';
            document.getElementById('exchangeNewsEmpty').style.display = 'none';
        }

        // Show error state for exchange news
        function showExchangeNewsError() {
            document.getElementById('exchangeNewsLoading').style.display = 'none';
            document.getElementById('exchangeNewsContent').style.display = 'none';
            document.getElementById('exchangeNewsError').style.display = 'block';
            document.getElementById('exchangeNewsEmpty').style.display = 'none';
        }

        // Refresh exchange news manually
        async function refreshExchangeNews() {
            const refreshBtn = document.getElementById('refreshExchangeNewsBtn');
            const originalText = refreshBtn.textContent;
            
            refreshBtn.textContent = 'üîÑ ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ™ÿ≠ÿØŸäÿ´...';
            refreshBtn.disabled = true;
            
            try {
                await loadExchangeNews(true); // Force refresh
                showStatus('ÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿ´ ÿ•ÿπŸÑÿßŸÜÿßÿ™ ÿßŸÑÿ®Ÿàÿ±ÿµÿ© ÿ®ŸÜÿ¨ÿßÿ≠!', 'success');
            } catch (error) {
                console.error('Error refreshing exchange news:', error);
                showStatus('ŸÅÿ¥ŸÑ ŸÅŸä ÿ™ÿ≠ÿØŸäÿ´ ÿ•ÿπŸÑÿßŸÜÿßÿ™ ÿßŸÑÿ®Ÿàÿ±ÿµÿ©', 'error');
            } finally {
                refreshBtn.textContent = originalText;
                refreshBtn.disabled = false;
            }
        }

        // Open exchange news link in external browser
        function openExchangeNewsLink(url) {
            if (url && url !== 'https://www.mubasher.info/news/eg/now/announcements') {
                console.log('üì∞ Opening exchange news link:', url);
                
                // Use electron's shell to open external link
                if (typeof require !== 'undefined') {
                    const { shell } = require('electron');
                    shell.openExternal(url);
                } else {
                    // Fallback for web version
                    window.open(url, '_blank');
                }
            } else {
                console.log('üì∞ No specific URL available for this news item');
            }
        }

        // Load cached exchange news on startup
        function loadCachedExchangeNews() {
            try {
                const cached = localStorage.getItem('cachedExchangeNews');
                const lastCheck = localStorage.getItem('lastExchangeNewsCheck');
                
                if (cached && lastCheck) {
                    exchangeNewsData = JSON.parse(cached);
                    
                    // Show cached news immediately if on exchange news tab
                    const activeTab = document.querySelector('.tab-content.active');
                    if (activeTab && activeTab.id === 'exchange-news') {
                        displayExchangeNews(exchangeNewsData);
                    }
                    console.log('üì∞ Loaded cached exchange news');
                }
            } catch (error) {
                console.error('Error loading cached exchange news:', error);
            }
        }

        // Handle notification display
        ipcRenderer.on('show-notification', (event, message) => {
            console.log('Notification:', message);
            showStatus(message, 'info');
        });

        // Audio handling
        let currentAudio = null;
        let currentVolume = 0.7;

        // Listen for audio playback requests from main process
        ipcRenderer.on('play-audio', (event, data) => {
            console.log('Received audio play request:', data);
            playInternalAudio(data.filePath, data.volume);
        });

        // Listen for beep sound requests from main process
        ipcRenderer.on('play-beep', (event, data) => {
            console.log('Received beep play request:', data);
            playBeepSound(data.volume);
        });

        // Internal audio player
        function playInternalAudio(filePath, volume = 0.7) {
            try {
                console.log('Playing internal audio:', filePath, 'Volume:', volume);
                
                // Stop any currently playing audio
                stopCurrentAudio();
                
                // Create audio element
                const audio = new Audio();
                audio.src = filePath;
                audio.volume = volume;
                audio.preload = 'auto';
                
                // Store reference to current audio
                currentAudio = audio;
                
                // Play the audio
                audio.play().then(() => {
                    console.log('Audio started playing successfully');
                }).catch((error) => {
                    console.error('Error playing audio:', error);
                    // Fallback to beep if audio fails
                    playBeepSound(volume);
                });
                
                // Clean up after audio ends
                audio.addEventListener('ended', () => {
                    console.log('Audio finished playing');
                    stopCurrentAudio();
                });
                
                // Handle errors
                audio.addEventListener('error', (error) => {
                    console.error('Audio error:', error);
                    playBeepSound(volume);
                });
                
            } catch (error) {
                console.error('Error setting up internal audio:', error);
                playBeepSound(volume);
            }
        }

        // Stop current audio
        function stopCurrentAudio() {
            if (currentAudio) {
                console.log('Stopping current audio');
                currentAudio.pause();
                currentAudio.currentTime = 0;
                currentAudio.remove();
                currentAudio = null;
            }
        }

        // Fallback beep sound
        function playBeepSound(volume = 0.7) {
            try {
                // Create a simple beep sound using Web Audio API
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                oscillator.frequency.setValueAtTime(1000, audioContext.currentTime + 0.1);
                oscillator.frequency.setValueAtTime(1200, audioContext.currentTime + 0.2);
                
                // Use the volume parameter
                const beepVolume = volume * 0.3; // Scale down the beep volume
                gainNode.gain.setValueAtTime(beepVolume, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.5);
                
            } catch (error) {
                console.error('Error playing beep sound:', error);
            }
        }

        // Setup volume slider
        function setupVolumeSlider() {
            const volumeSlider = document.getElementById('notificationVolume');
            const volumeDisplay = document.getElementById('volumeDisplay');
            
            if (volumeSlider && volumeDisplay) {
                // Load initial volume from settings
                loadInitialVolume();
                
                // Update volume display
                function updateVolumeDisplay() {
                    const volume = parseFloat(volumeSlider.value);
                    currentVolume = volume;
                    volumeDisplay.textContent = Math.round(volume * 100) + '%';
                    
                    // Update current audio volume in real-time
                    updateCurrentAudioVolume(volume);
                }
                
                // Real-time volume updates
                volumeSlider.addEventListener('input', updateVolumeDisplay);
                
                // Save volume setting when user stops dragging
                volumeSlider.addEventListener('change', () => {
                    const volume = parseFloat(volumeSlider.value);
                    currentVolume = volume;
                    saveVolumeSetting(volume);
                });
            }
        }

        // Setup update interval input
        function setupUpdateInterval() {
            const updateIntervalInput = document.getElementById('updateInterval');
            const intervalDisplay = document.getElementById('intervalDisplay');
            
            if (updateIntervalInput && intervalDisplay) {
                // Update interval display
                function updateIntervalDisplay() {
                    const interval = parseInt(updateIntervalInput.value);
                    intervalDisplay.textContent = interval + ' seconds';
                }
                
                // Real-time interval updates
                updateIntervalInput.addEventListener('input', updateIntervalDisplay);
                
                // Validate interval range
                updateIntervalInput.addEventListener('change', () => {
                    let interval = parseInt(updateIntervalInput.value);
                    
                    // Ensure interval is within valid range
                    if (interval < 5) {
                        interval = 5;
                        updateIntervalInput.value = 5;
                    } else if (interval > 300) {
                        interval = 300;
                        updateIntervalInput.value = 300;
                    }
                    
                    intervalDisplay.textContent = interval + ' seconds';
                });
            }
        }

        // Load initial volume from settings
        async function loadInitialVolume() {
            try {
                const settings = await ipcRenderer.invoke('get-settings');
                const volume = settings.notificationVolume || 0.7;
                
                const volumeSlider = document.getElementById('notificationVolume');
                const volumeDisplay = document.getElementById('volumeDisplay');
                
                if (volumeSlider && volumeDisplay) {
                    volumeSlider.value = volume;
                    currentVolume = volume;
                    volumeDisplay.textContent = Math.round(volume * 100) + '%';
                    console.log('Volume initialized on startup:', volume);
                }
            } catch (error) {
                console.error('Error loading initial volume:', error);
                // Set default volume
                currentVolume = 0.7;
            }
        }

        // Update current audio volume
        function updateCurrentAudioVolume(volume) {
            if (currentAudio) {
                currentAudio.volume = volume;
                console.log('Updated audio volume to:', volume);
            }
        }

        // Save volume setting
        function saveVolumeSetting(volume) {
            // Send to main process to save
            ipcRenderer.invoke('update-settings', {
                notificationVolume: volume
            });
            console.log('Volume setting saved:', volume);
        }

        // Widget window functions
        async function toggleWidgetWindow() {
            try {
                const result = await ipcRenderer.invoke('toggle-widget-window');
                if (result && result.success !== undefined) {
                    // Update the checkbox based on widget visibility
                    const widgetEnabledCheckbox = document.getElementById('widgetEnabled');
                    if (widgetEnabledCheckbox) {
                        widgetEnabledCheckbox.checked = result.visible || false;
                        // Save the setting
                        await saveSettings();
                    }
                    // Send current watchlist to widget
                    sendWatchlistToWidget();
                }
            } catch (error) {
                console.error('Error toggling widget window:', error);
                showStatus('Error toggling widget window: ' + error.message, 'error');
            }
        }
        
        
        // Setup widget opacity slider
        function setupWidgetOpacitySlider() {
            const opacitySlider = document.getElementById('widgetOpacity');
            const opacityDisplay = document.getElementById('widgetOpacityDisplay');
            
            if (opacitySlider && opacityDisplay) {
                function updateOpacityDisplay() {
                    const opacity = parseFloat(opacitySlider.value);
                    opacityDisplay.textContent = Math.round(opacity * 100) + '%';
                }
                
                opacitySlider.addEventListener('input', updateOpacityDisplay);
                opacitySlider.addEventListener('change', updateOpacityDisplay);
            }
        }
        
        // Setup widget enabled checkbox
        function setupWidgetEnabledCheckbox() {
            const widgetEnabledCheckbox = document.getElementById('widgetEnabled');
            
            if (widgetEnabledCheckbox) {
                widgetEnabledCheckbox.addEventListener('change', async function() {
                    try {
                        if (this.checked) {
                            // Show widget
                            await ipcRenderer.invoke('show-widget-window');
                        } else {
                            // Hide widget
                            await ipcRenderer.invoke('hide-widget-window');
                        }
                        // Save settings
                        await saveSettings();
                    } catch (error) {
                        console.error('Error toggling widget from checkbox:', error);
                        showStatus('Error toggling widget: ' + error.message, 'error');
                    }
                });
            }
        }

        // Test notification sound function
        async function testNotificationSound() {
            try {
                const testSoundBtn = document.getElementById('testSoundBtn');
                const originalText = testSoundBtn.textContent;
                
                // Disable button and show testing status
                testSoundBtn.disabled = true;
                testSoundBtn.textContent = 'üîä Testing...';
                
                // Play the notification sound directly using internal audio with current volume
                const soundPath = 'assets/Bell Sound Effects.m4a';
                playInternalAudio(soundPath, currentVolume);
                
                showStatus('Test sound played successfully', 'success');
            } catch (error) {
                console.error('Error testing notification sound:', error);
                showStatus('Error testing sound: ' + error.message, 'error');
            } finally {
                // Re-enable button after a short delay
                setTimeout(() => {
                    const testSoundBtn = document.getElementById('testSoundBtn');
                    testSoundBtn.disabled = false;
                    testSoundBtn.textContent = 'üîä Test Sound';
                }, 1000);
            }
        }

        // Simple update system - no complex event handlers needed

        // Simple update modal functions
        function showUpdateAvailableModal(info) {
            document.getElementById('updateVersion').textContent = info.version;
            document.getElementById('updateReleaseNotes').textContent = info.releaseNotes || 'No release notes available';
            document.getElementById('updateReleaseDate').textContent = new Date(info.releaseDate).toLocaleDateString();
            
            document.getElementById('updateModal').style.display = 'flex';
        }

        function hideUpdateModal() {
            document.getElementById('updateModal').style.display = 'none';
        }

        async function openDownloadPage() {
            try {
                await ipcRenderer.invoke('open-download-page');
                hideUpdateModal();
                showStatus('Download page opened in browser', 'success');
            } catch (error) {
                console.error('Error opening download page:', error);
                showStatus('Error opening download page: ' + error.message, 'error');
            }
        }

        // Settings modal functions
        async function showSettingsModal() {
            document.getElementById('settingsModal').style.display = 'flex';
            await loadSettings();
        }

        function hideSettingsModal() {
            document.getElementById('settingsModal').style.display = 'none';
        }

        async function loadSettings() {
            try {
                // Small delay to ensure DOM is ready
                await new Promise(resolve => setTimeout(resolve, 100));
                
                const settings = await ipcRenderer.invoke('get-settings');
                console.log('Loading settings:', settings);
                
                // Set checkbox states based on loaded settings
                const autoUpdateCheckbox = document.getElementById('autoUpdateEnabled');
                const minimizeToTrayCheckbox = document.getElementById('minimizeToTray');
                const closeToTrayCheckbox = document.getElementById('closeToTray');
                const playNotificationCheckbox = document.getElementById('playNotification');
                
                if (autoUpdateCheckbox) {
                    autoUpdateCheckbox.checked = settings.autoUpdate === true;
                    console.log('Auto update checkbox set to:', autoUpdateCheckbox.checked);
                }
                if (minimizeToTrayCheckbox) {
                    minimizeToTrayCheckbox.checked = settings.minimizeToTray === true;
                    console.log('Minimize to tray checkbox set to:', minimizeToTrayCheckbox.checked);
                }
                if (closeToTrayCheckbox) {
                    closeToTrayCheckbox.checked = settings.closeToTray === true;
                    console.log('Close to tray checkbox set to:', closeToTrayCheckbox.checked);
                }
                if (playNotificationCheckbox) {
                    playNotificationCheckbox.checked = settings.playNotification === true;
                    console.log('Play notification checkbox set to:', playNotificationCheckbox.checked);
                }
                
                // Set volume slider
                const volumeSlider = document.getElementById('notificationVolume');
                const volumeDisplay = document.getElementById('volumeDisplay');
                
                if (volumeSlider && volumeDisplay && settings.notificationVolume !== undefined) {
                    volumeSlider.value = settings.notificationVolume;
                    currentVolume = settings.notificationVolume;
                    volumeDisplay.textContent = Math.round(settings.notificationVolume * 100) + '%';
                    console.log('Volume slider set to:', settings.notificationVolume);
                }
                
                // Set time inputs
                const marketOpenTimeInput = document.getElementById('marketOpenTime');
                const marketCloseTimeInput = document.getElementById('marketCloseTime');
                
                if (marketOpenTimeInput && settings.marketOpenTime) {
                    const openTime = `${settings.marketOpenTime.hour.toString().padStart(2, '0')}:${settings.marketOpenTime.minute.toString().padStart(2, '0')}`;
                    marketOpenTimeInput.value = openTime;
                    console.log('Market open time set to:', openTime);
                }
                if (marketCloseTimeInput && settings.marketCloseTime) {
                    const closeTime = `${settings.marketCloseTime.hour.toString().padStart(2, '0')}:${settings.marketCloseTime.minute.toString().padStart(2, '0')}`;
                    marketCloseTimeInput.value = closeTime;
                    console.log('Market close time set to:', closeTime);
                }
                
                // Set update interval
                const updateIntervalInput = document.getElementById('updateInterval');
                const intervalDisplay = document.getElementById('intervalDisplay');
                
                if (updateIntervalInput && intervalDisplay && settings.updateInterval !== undefined) {
                    updateIntervalInput.value = settings.updateInterval;
                    intervalDisplay.textContent = settings.updateInterval + ' seconds';
                    console.log('Update interval set to:', settings.updateInterval, 'seconds');
                }
                
                // Set days off checkboxes
                const dayCheckboxes = {
                    sundayOff: settings.daysOff?.sunday || false,
                    mondayOff: settings.daysOff?.monday || false,
                    tuesdayOff: settings.daysOff?.tuesday || false,
                    wednesdayOff: settings.daysOff?.wednesday || false,
                    thursdayOff: settings.daysOff?.thursday || false,
                    fridayOff: settings.daysOff?.friday || false,
                    saturdayOff: settings.daysOff?.saturday || false
                };
                
                Object.keys(dayCheckboxes).forEach(checkboxId => {
                    const checkbox = document.getElementById(checkboxId);
                    if (checkbox) {
                        checkbox.checked = dayCheckboxes[checkboxId];
                        console.log(`${checkboxId} set to:`, dayCheckboxes[checkboxId]);
                    }
                });
                
                // Set widget window settings
                const widgetEnabledCheckbox = document.getElementById('widgetEnabled');
                const widgetAlwaysOnTopCheckbox = document.getElementById('widgetAlwaysOnTop');
                const widgetOpacitySlider = document.getElementById('widgetOpacity');
                const widgetOpacityDisplay = document.getElementById('widgetOpacityDisplay');
                
                if (widgetEnabledCheckbox) {
                    widgetEnabledCheckbox.checked = settings.widgetWindow?.enabled || false;
                }
                if (widgetAlwaysOnTopCheckbox) {
                    widgetAlwaysOnTopCheckbox.checked = settings.widgetWindow?.alwaysOnTop || false;
                }
                if (widgetOpacitySlider && widgetOpacityDisplay) {
                    const opacity = settings.widgetWindow?.opacity || 0.9;
                    widgetOpacitySlider.value = opacity;
                    widgetOpacityDisplay.textContent = Math.round(opacity * 100) + '%';
                }
                
                console.log('Settings loaded successfully');
            } catch (error) {
                console.error('Error loading settings:', error);
                // Set default values if loading fails
                const autoUpdateCheckbox = document.getElementById('autoUpdateEnabled');
                const minimizeToTrayCheckbox = document.getElementById('minimizeToTray');
                const closeToTrayCheckbox = document.getElementById('closeToTray');
                const playNotificationCheckbox = document.getElementById('playNotification');
                
                if (autoUpdateCheckbox) autoUpdateCheckbox.checked = true;
                if (minimizeToTrayCheckbox) minimizeToTrayCheckbox.checked = true;
                if (closeToTrayCheckbox) closeToTrayCheckbox.checked = true;
                if (playNotificationCheckbox) playNotificationCheckbox.checked = true;
            }
        }

        async function saveSettings() {
            try {
                const autoUpdateCheckbox = document.getElementById('autoUpdateEnabled');
                const minimizeToTrayCheckbox = document.getElementById('minimizeToTray');
                const closeToTrayCheckbox = document.getElementById('closeToTray');
                const playNotificationCheckbox = document.getElementById('playNotification');
                const volumeSlider = document.getElementById('notificationVolume');
                const marketOpenTimeInput = document.getElementById('marketOpenTime');
                const marketCloseTimeInput = document.getElementById('marketCloseTime');
                const updateIntervalInput = document.getElementById('updateInterval');
                
                // Get days off checkboxes
                const sundayOffCheckbox = document.getElementById('sundayOff');
                const mondayOffCheckbox = document.getElementById('mondayOff');
                const tuesdayOffCheckbox = document.getElementById('tuesdayOff');
                const wednesdayOffCheckbox = document.getElementById('wednesdayOff');
                const thursdayOffCheckbox = document.getElementById('thursdayOff');
                const fridayOffCheckbox = document.getElementById('fridayOff');
                const saturdayOffCheckbox = document.getElementById('saturdayOff');
                
                // Get widget window settings
                const widgetEnabledCheckbox = document.getElementById('widgetEnabled');
                const widgetAlwaysOnTopCheckbox = document.getElementById('widgetAlwaysOnTop');
                const widgetOpacitySlider = document.getElementById('widgetOpacity');
                
                if (!autoUpdateCheckbox || !minimizeToTrayCheckbox || !closeToTrayCheckbox || 
                    !playNotificationCheckbox || !volumeSlider || !marketOpenTimeInput || !marketCloseTimeInput || !updateIntervalInput ||
                    !sundayOffCheckbox || !mondayOffCheckbox || !tuesdayOffCheckbox || !wednesdayOffCheckbox || 
                    !thursdayOffCheckbox || !fridayOffCheckbox || !saturdayOffCheckbox ||
                    !widgetEnabledCheckbox || !widgetAlwaysOnTopCheckbox || !widgetOpacitySlider) {
                    console.error('One or more form elements not found');
                    showStatus('Error: Settings form elements not found', 'error');
                    return;
                }
                
                const autoUpdateEnabled = autoUpdateCheckbox.checked;
                const minimizeToTray = minimizeToTrayCheckbox.checked;
                const closeToTray = closeToTrayCheckbox.checked;
                const playNotification = playNotificationCheckbox.checked;
                const notificationVolume = parseFloat(volumeSlider.value);
                const updateInterval = parseInt(updateIntervalInput.value);
                
                // Parse time inputs
                const openTimeValue = marketOpenTimeInput.value;
                const closeTimeValue = marketCloseTimeInput.value;
                
                const [openHour, openMinute] = openTimeValue.split(':').map(Number);
                const [closeHour, closeMinute] = closeTimeValue.split(':').map(Number);
                
                const marketOpenTime = { hour: openHour, minute: openMinute };
                const marketCloseTime = { hour: closeHour, minute: closeMinute };
                
                // Get days off settings
                const daysOff = {
                    sunday: sundayOffCheckbox.checked,
                    monday: mondayOffCheckbox.checked,
                    tuesday: tuesdayOffCheckbox.checked,
                    wednesday: wednesdayOffCheckbox.checked,
                    thursday: thursdayOffCheckbox.checked,
                    friday: fridayOffCheckbox.checked,
                    saturday: saturdayOffCheckbox.checked
                };
                
                // Get widget window settings
                const widgetWindow = {
                    enabled: widgetEnabledCheckbox.checked,
                    alwaysOnTop: widgetAlwaysOnTopCheckbox.checked,
                    transparent: parseFloat(widgetOpacitySlider.value) < 1.0, // Auto-detect transparency based on opacity
                    opacity: parseFloat(widgetOpacitySlider.value)
                };
                
                console.log('Saving settings:', {
                    autoUpdate: autoUpdateEnabled,
                    minimizeToTray: minimizeToTray,
                    closeToTray: closeToTray,
                    playNotification: playNotification,
                    notificationVolume: notificationVolume,
                    marketOpenTime: marketOpenTime,
                    marketCloseTime: marketCloseTime,
                    updateInterval: updateInterval,
                    daysOff: daysOff,
                    widgetWindow: widgetWindow
                });
                
                const result = await ipcRenderer.invoke('update-settings', { 
                    autoUpdate: autoUpdateEnabled,
                    minimizeToTray: minimizeToTray,
                    closeToTray: closeToTray,
                    playNotification: playNotification,
                    notificationVolume: notificationVolume,
                    marketOpenTime: marketOpenTime,
                    marketCloseTime: marketCloseTime,
                    updateInterval: updateInterval,
                    daysOff: daysOff,
                    widgetWindow: widgetWindow
                });
                
                console.log('Settings saved successfully:', result);
                
                // Reload refresh interval if it was changed
                if (updateInterval !== undefined) {
                    loadRefreshInterval();
                }
                
                showStatus('Settings saved successfully', 'success');
                hideSettingsModal();
            } catch (error) {
                console.error('Error saving settings:', error);
                showStatus('Error saving settings: ' + error.message, 'error');
            }
        }


        async function checkForUpdates() {
            const checkUpdateBtn = document.getElementById('checkUpdateBtn');
            
            // Disable button and show checking status
            checkUpdateBtn.disabled = true;
            checkUpdateBtn.textContent = '‚è≥ Checking...';
            
            try {
                showStatus('Checking for updates...', 'info');
                
                // Add timeout to prevent getting stuck
                const updatePromise = ipcRenderer.invoke('check-for-updates');
                const timeoutPromise = new Promise((_, reject) => 
                    setTimeout(() => reject(new Error('Update check timeout')), 10000)
                );
                
                await Promise.race([updatePromise, timeoutPromise]);
            } catch (error) {
                console.error('Error checking for updates:', error);
                showStatus('Error checking for updates: ' + error.message, 'error');
            } finally {
                checkUpdateBtn.disabled = false;
                checkUpdateBtn.textContent = 'üîç Check for Updates';
            }
        }
    </script>

    <!-- Footer -->
    <footer style="
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: rgba(20, 20, 40, 0.95);
        backdrop-filter: blur(10px);
        padding: 12px 20px;
        border-top: 1px solid rgba(255, 255, 255, 0.1);
        text-align: center;
        font-size: 0.8em;
        color: #b0b0b0;
        z-index: 1000;
        height: 50px;
        box-sizing: border-box;
        display: flex;
        align-items: center;
        justify-content: center;
    ">
        <p style="margin: 0;">The Egyptian Exchange App v<span id="appVersion">0.9.2</span> - Developed by <a href="https://github.com/AMoussa77/The-Egyptian-Exchange/releases" target="_blank" style="color: #4a90e2; text-decoration: none;">A Moussa</a></p>
    </footer>
</body>
</html>
